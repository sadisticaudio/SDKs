/*
 PaceEdenPublicCommon.thriftclass
 
 Copyright (C) 2012 - 2016, PACE Anti-Piracy, Inc., All rights reserved
 
 This thriftclass file defines the PACE Eden Interface thrift items (structures, enums, constants, etc,).  
 These items are passed between developer code and the PACE Eden Interface and are used extensively within
 the PACE library code.  This file is used by PACE to generate the thrift code needed to use the PACE Eden Interface.  
 Developers do not have to generate the thrift code themselves, because this code have been provided to developers by 
 PACE.  For developers, this file is very useful in explaining the thrift items used in the PACE Eden Interface.
*/


// *******************************************************
// Namespace declarations
// *******************************************************
namespace cpp pace.eden.thrift.pub
namespace java com.paceap.eden.thrift.pub.common
namespace csharp pace.eden.thrift.pub.common
namespace rb pace.eden.thrift.pub.common

// Note that the following namespaces here is specific to our Eden Services API. It is necessary
// in order to have generated python code refer to other generated python code by full module
// paths without requiring path changes to our customers environment variables.
namespace py edenremotepy.pub.PaceEdenPublicCommon
namespace php edenremotephp.pub.PaceEdenPublicCommon
namespace perl edenremoteperl.pub.PaceEdenPublicCommon


// *******************************************************
// Authorization Enums and constants
// *******************************************************

//-----------------------
/** 
AuthType:  These define the general types of auths.
*/
enum kAuthType
{
	kGroup =			0x0000000000000001, /** Unlocked group Auth */ 
	kFeature =			0x0000000000000002,
	kBundle =			0x0000000000000004, /** Locked group Auth */ 
	kProduct =			0x0000000000000008,	/** All iLok1 auths will be of type kProduct. */
}
/** Typedef to force the size of kAuthType enums to 64-bit in structures. */
typedef i64 eAuthType	
/** Constant for searching for auths with any kAuthType, even ones that are not defined yet. */
const eAuthType kAllAuthTypes	= -1, //0xFFFFFFFFFFFFFFFF


//-----------------------
/** 
Subtype:  These define more detailed Subtypes of auths.
*/
enum kSubtype
{
	kFull =				0x0000000000000001,
	kActivatedDemo =	0x0000000000000002,
	kBlindDemo =		0x0000000000000004,
	kRental =			0x0000000000000008,
	kTemporary =		0x0000000000000010,
	kNfr =				0x0000000000000020, /** Not For Resale */
	kBackup =			0x0000000000000040,
	kSubscription =		0x0000000000000080,
	kMaster =			0x0000000000000100,
	kEmployee =			0x0000000000000200,
	kTraining =			0x0000000000000400,
	kBeta =				0x0000000000000800,
	kTrialExtension =	0x0000000000001000,
	kNfrSubscription =	0x0000000000002000,
}
/** Typedef to force the size of kSubtype enums to 64-bit in structures. */
typedef i64 eSubtype
/** Constant for searching for auths with any kSubtype, even ones that are not defined yet. */
const eSubtype kAllSubtypes	= -1, //0xFFFFFFFFFFFFFFFF


//-----------------------
/** 
AuthState:  These are the various states of an auth.
*/
enum kAuthState
{
	kActive =			0x0000000000000001,
	kInactive =			0x0000000000000002,
	kExpired =			0x0000000000000004,
	kNotValidYet =		0x0000000000000008,
	kRevoked =			0x0000000000000010,
	kMisconfigured =	0x0000000000000020,
}
/** Typedef to force the size of kAuthState enums to 64-bit in structures */
typedef i64 eAuthState
/** Constant for searching for auths with any kAuthState */
const eAuthState kAllStates	= -1, //0xFFFFFFFFFFFFFFFF


//-----------------------
/** 
AuthAttributes:  These are the attributes of an auth.  Attributes are separated into groups.  For example, 
				 Unlimited, CountLimitedOnly, TimeLimitedOnly and TimeAndCountLimited are in the Terms Limit Group.  
				 An Auth  will always contain one attribute each group.  For searches, if none of the attributes are 
				 specified in a group, then it is assumed that matching auths with any attributes in that group is okay.
				 For example, if both the Invisible and Visible attributes are not included in an auth search, then 
				 these attributes are not used to limit the auths found.  To just find visible auths, then just set 
				 the Visible (not the Invisible) attribute in the auth search.
*/
enum kAuthAttributes
{
	//------------
	// Attribute Groups
	
	/** Terms Limit Group - Indicates the limits that apply to the auth. */
	kUnlimited =				0x0000000000000001,		/** The auth is NOT Time limited and NOT Count limited. */
	kCountLimitedOnly =			0x0000000000000002,		/** The auth is Count limited, but NOT Time limited. */
	kTimeLimitedOnly =			0x0000000000000004,		/** The auth is Time limited, but NOT Count limited. */
	kTimeAndCountLimited =		0x0000000000000008,		/** The auth is Time and Count limited. */
	
	/** Auth End-User Visibility Group - Indicates if the auth should be displayed to end-users or not. */
	kInvisible =				0x0000000000000010,
	kVisible =					0x0000000000000020,		/** iLok1 auths are always be kVisible. */
	
	/** Strict Parent Group - Strict means that all descendant auths must this respect this auth's terms limits as well as their own terms limits. */
	kNonStrictParent =			0x0000000000000040,		/** iLok1 auths are always be kNonStrictParent, since iLok1 has not auth hierarchy. */
	kStrictParent =				0x0000000000000080,
	
	/** License Group - Indicates if an auth belongs in the same license as its parent or not.  A license is a group of auths that belong together. */
	kNotLicensedWithParent =	0x0000000000000100,		/** iLok1 auths are always be kNotLicensedWithParent, since iLok1 has not auth hierarchy. */
	kLicensedWithParent =		0x0000000000000200,

	/** Test/Production Group - Eden modern locations have a flag to indicate if and auth is a test auth or not.  ILok1 auths will always show up as production auths.*/
	kTestAuth =					0x0000000000000400,		/** The auth was created by a test tool or test tool. */
	kProductionNonTestAuth =	0x0000000000000800,		/** The auth was created by the production Eden server or iLok manufacturing software. */
	
	/** Legacy Token 56 Group - Warning: Niether of these will be set unless updateLegacyTokenState in the findAuthOptions/verifyAuthOption is true. */
	kToken56_Off =				0x0000000000001000,		/** Legacy Token number 56 is NOT enabled. */
	kToken56_On =				0x0000000000002000,		/** Legacy Token number 56 IS enabled. */

	/** Legacy Token 57 Group - Warning: Niether of these will be set unless updateLegacyTokenState in the findAuthOptions/verifyAuthOption is true. */
	kToken57_Off =				0x0000000000004000,		/** Legacy Token number 57 is NOT enabled. */
	kToken57_On =				0x0000000000008000,		/** Legacy Token number 57 IS enabled. */

	/** Legacy Token 58 Group - Warning: Niether of these will be set unless updateLegacyTokenState in the findAuthOptions/verifyAuthOption is true. */
	kToken58_Off =				0x0000000000010000,		/** Legacy Token number 58 is NOT enabled. */
	kToken58_On =				0x0000000000020000,		/** Legacy Token number 58 IS enabled. */

	/** Legacy Token 59 Group - Warning: Niether of these will be set unless updateLegacyTokenState in the findAuthOptions/verifyAuthOption is true. */
	kToken59_Off =				0x0000000000040000,		/** Legacy Token number 59 is NOT enabled. */
	kToken59_On =				0x0000000000080000,		/** Legacy Token number 59 IS enabled. */
	
	/** License Sharing Group - Indicates is a license is sharable over the network or not. */
	kNonSharedLicense =			0x0000000000100000,		/** The license is not sharable over the network. Can't be used with an iLok Server. */
	kSharedLicense =			0x0000000000200000,		/** The license is sharable over the network. Can be used with an iLok Server. */
	
	//------------
	/** Convenient Combos for Searching Term Limits */
	kCountLimitSearch =			0x000000000000000A,		/** Any Auth with a Count limit. */
	kTimeLimitSearch =			0x000000000000000C,		/** Any Auth with a Time limit. */
	kTermsLimitedSearch =		0x000000000000000E,		/** Any Auth with a some kind of terms limit (Count and/or Time limit). */
}
/** Typedef to force the size of kAuthAttributes enums to 64-bit in structures. */
typedef i64 eAuthAttributes
/** Constant for searching for auths with any kAuthAttributes */
const eAuthAttributes kAllAttributes	= -1, //0xFFFFFFFFFFFFFFFF


//-----------------------
/** 
LocationType:  These are the available types of locations that hold auths.
*/
enum kLocationType
{
	kLicenseDb =		0x0000000000000001,	/** License Database on the computer executing the protected program. */
	kIlok1 =			0x0000000000000002,	/** ILok1 directly connected to the computer executing the protected program. */
	kIlok2 =			0x0000000000000004,	/** ILok2 directly connected to the computer executing the protected program. */
	kIlok2Remote =		0x0000000000000008,	/** ILok2 remotely connected via an iLok Server to the computer executing the protected program. */
	kLicenseDbRemote =	0x0000000000000010,	/** License Database remotely via an iLok Server connected to the computer executing the 
												protected program. (Possible future remote location.)*/
	kIlok3 =			0x0000000000000020,	/** ILok3 directly connected to the computer executing the protected program. (Possible future iLok)*/
	kIlok3Remote =		0x0000000000000040,	/** ILok3 remotely connected via an iLok Server to the computer executing the protected program.
												(Possible future remote iLok) */
}
/** Typedef to force the size of kLocationType enums to 64-bit in structures. */
typedef i64 eLocationType
/** Constant searching for auths in any location. */
const eLocationType kAllLocationTypes =			-1, //0xFFFFFFFFFFFFFFFF


//-----------------------
/** 
LocationGroup:  Abstract groups that can be used instead of specifying the LocationType.  The advantage of using 
				a LocationGroup to search for auths is that the locations in the group will automatically grow as new  
				locations are created.  Using LocationType to search for auths hard codes the locations that will be 
				searched.
*/
enum eLocationGroup
{
	//------------
	// No LocationGroup; use LocationTypes.
	eUseLocationTypes = 0,			/** Set locationGroup to this value to specify location by locationType; otherwise 
											locationType will be ignored. */
	
	eAllLocations_LocationGroup,	/** All locations: Same as using kAllLocationTypes in the eLocationType. */

	//------------
	// Basic LocationGroups; ignore LocationTypes.
	eEdenModern_LocationGroup,	/** These are the locationTypes that support Eden modern features (kIlok2, kIlok3, kLicenseDb, 
									etc.), regardless of whether they are local or remote. */
	eIlok_LocationGroup,		/** These are the iLok device locationTypes (kIlok1, kIlok2, kIlok3, etc.), regardless of 
									whether they are local or remote. */
	eLocal_LocationGroup,		/** These are all locationTypes (kIlok1, kIlok2, kIlok3, kLicenseDb, etc.) directly connected 
									to or on the computer where the protected software is being run. */
	eRemote_LocationGroup,		/** These are remote locationTypes (kIlok2Remote, kIlok3Remote, etc.) NOT directly connected to or  
									on the computer where the  protected software is being run.  For example, a location  on an     
									iLok Server connected to a client computer over a network is a remote location to the client. */
	eSwLicense_LocationGroup,	/** These are the software license locationTypes (kLicenseDb, etc.), regardless of 
									whether they are local or remote. */

	//------------
	// Double Combo LocationGroups; ignore LocationTypes.
	eEdenModernIlok_LocationGroup,		/** The location must be in both groups: kEdenModern_LocationGroup and kIlok_LocationGroup. */
	eEdenModernSwLicense_LocationGroup,	/** The location must be in both groups: kEdenModern_LocationGroup and kSwLicense_LocationGroup. */
	eLocalEdenModern_LocationGroup,		/** The location must be in both groups: kLocal_LocationGroup and kEdenModern_LocationGroup. */
	eLocalIlok_LocationGroup,			/** The location must be in both groups: kLocal_LocationGroup and kIlok_LocationGroup. */
	eLocalSwLicense_LocationGroup,		/** The location must be in both groups: kLocal_LocationGroup and kSwLicense_LocationGroup. */
	eRemoteEdenModern_LocationGroup,	/** The location must be in both groups: kRemote_LocationGroup and kEdenModern_LocationGroup. */
	eRemoteIlok_LocationGroup,			/** The location must be in both groups: kRemote_LocationGroup and kIlok_LocationGroup. */
	eRemoteSwLicense_LocationGroup,		/** The location must be in both groups: kRemote_LocationGroup and kSwLicense_LocationGroup. */

	//------------
	// Triple Combo LocationGroups; ignore LocationTypes.
	eLocalEdenModernIlok_LocationGroup,			/** The location must be in the 3 groups: kLocal_LocationGroup, kEdenModern_LocationGroup & kIlok_LocationGroup. */
	eLocalEdenModernSwLicense_LocationGroup,	/** The location must be in the 3 groups: kLocal_LocationGroup, kEdenModern_LocationGroup & kSwLicense_LocationGroup. */
	eRemoteEdenModernIlok_LocationGroup,		/** The location must be in the 3 groups: kRemote_LocationGroup, kEdenModern_LocationGroup & kIlok_LocationGroup. */
	eRemoteEdenModernSwLicense_LocationGroup,	/** The location must be in the 3 groups: kRemote_LocationGroup, kEdenModern_LocationGroup & kSwLicense_LocationGroup. */
}


//-----------------------
/** 
TypeOfSecret:  Types of secrets that can be stored in SecretDataRecords. 
*/
enum eTypeOfSecret
{
	kSymmetricKey = 0,  // Intended to be use as a symmetric key with the algorithm defined by eEncryptionAlgorithmId, but secret may not be limited to this intended use.
	kAsymmetricKey,		// Intended to be use as an asymmetric key with the algorithm defined by ePkStandardId, but secret may not be limited to this intended use.
	kPassword,			// A password that can be verified and possibly changed.
	kPrivateData,		// Not for use by callers.
}


//-----------------------
/**
EncryptionAlgorithmId:  Symmetric Key Encryption Algorithm IDs associated with SecretDataRecords and encryption code.
*/
enum eEncryptionAlgorithmId
{
	kAes128 = 0,
	kAes192,
	kAes256,
	kTwoFish128,
}


//-----------------------
/**
EncryptionMode:  Symmetric Key Encryption Mode associated with encryption code.
*/
enum eEncryptionMode
{
	kEcbMode = 0,	/** Electronic CodeBook: Block encryption with no feedback.  Not recommended for multiple blocks. */
	kCbcMode,		/** Cipher-Block Chaining: Feedback is exclusive or-ed into the plaintext before the encryption of each block.  
						Padding is required if data size is not a multiple of the block size. */
	kCfbMode,		/** Cipher FeedBack: Feedback is encrypted, and then the encrypted feedback is exclusive or-ed into the  
						plaintext to encrypt a block at a time. Then this process repeats.  Padding is NOT needed. */
}

//-----------------------
/**
EncryptionPadding:  Symmetric Key Encryption padding associated with encryption code.
*/
enum eEncryptionPadding
{
	/** No padding should be used. */
	kNoPadding = 0,
	
	/** PKCS5: Use Password-based Encryption Standard padding. See RFC 2898. */
	kPKCS5Padding = 1,
}

//-----------------------
/**
PkStandardId:  Asymmetric Key PKStandard IDs associated with SecretDataRecords and signing code. 

	Warning: PACE's kEccSecp160r1 signatures use 160-bit truncation for hashes that are larger than 160-bit.  However,
			 the standards have moved toward truncating based on an ECC curve's base point order, which is 161-bits for
			 kEccSecp160r1.  While the 160-bit truncated hashes are just as secure, the resulting signature may not 
			 be interoperable with external crypto systems.  If interoperable with external crypto systems is
			 important, use kEccSecp160r1 with a 160-bit hash (such as kSha1HashId), or use one of the other 
			 PkStandards.
*/
enum ePkStandardId
{
	kEccSecp160r1 = 0,
	kEccSecp192r1,
	kEccSecp224r1,
	kEccSecp256r1,
}
/** Used for parameters that can be either eEncryptionAlgorithmId or ePkStandardId. */
typedef i32 eAlgorithmId


//-----------------------
/**
HashId:  Hash algorithms associated with signing (cryptographically proving) of authorization data. 
*/
enum eHashAlgorithmId 
{
	kSha1HashId = 2,		// SHA1
	
	kSha224HashId = 4,		// SHA2-224
	kSha256HashId = 5,		// SHA2-256
	
	kSha3_224HashId = 10,	// SHA3-224
	kSha3_256HashId = 11,	// SHA3-256
}


//-----------------------
/**
WriteProperties:  Write properties for SecretDataRecords and DeveloperDataRecords.  These write properties pertain
				   to what code running on a user's computer can do.  The Eden server is not limited by these
				   properies, since the server has the privileges to write all data in these records.
*/
enum eWriteProperties
{
	eWriteWithPassword = 0,
	eWriteAlways,
	eWriteOnce,
	eWriteNever,
	eSettableNotClearableBits,
	eBadDataCannotWrite,		/** Data that has been flagged as bad/corrupt and cannot be written. */
}


//-----------------------
/**
SearchMode: These are AuthChain searching options.
 */
enum eSearchMode
{
	//------------
	// Use this is for normal auth searching.
	eNormal = 0,
	
	//------------
	// For testing purposes, cached or not cached search modes are useful.
	eCachedAuthsOnly,		
	eNonCachedAuthsOnly,
}


//-----------------------
/**
 ExpirationWarningAlgorithm:  These are the algorithms for how often to warn users about an upcoming auth expirations.
							  Except for eWarnNotApplicable and eWarnNever, all algorithms will indicate a warning on
							  the first check and always base their next warning calculations on the state when the last
							  warning occured.  The warning information is stored in athe License Database regardless of  
							  where the auth is located, and there is one record for each auth.  If you have multiple  
							  apps with different warning algorithms using the same limited auth, then a warning 
							  presented in the one app will update the state of the last warning in the record shared 
							  by both apps.  Both app will then continue using the updated state of the last warning 
							  in the shared warning record for there calculations for the next warning.  For more   
							  information about auth time limits and count limits, see the TimeLimitRecord and 
							  CountLimitRecord structures in this file.   For more information about the warning  
							  records, see the ExpirationWarning struct in this file.
 */
enum eExpirationWarningAlgorithm
{
	eWarnNotApplicable = 0,				/** This is used as an output indicator to callers that an expiration warning 
											is not applicable to an auth.  When choosing an expiration warning as an
											input, callers should choose from the algorithms below. */
	eWarnNever,							/** Warn never. */
	eWarnAlways,						/** Warn always (every launch). */
	eWarnFirstTimeOnly,					/** Warn on the first launch and the first time the warning rules are changed. */
	eWarnTimeRegularly,					/** Warn if a fixed amount of time has passed since the last warning.  The  
											fixed amount in number of seconds is defined in the warning record's parameter1.
											This algorithm operates independently from any time limit the auth might have. */
	eWarnCountRegularly,				/** Warn every X number of launches.  The warning record's parameter1 is X. 
											This algorithm operates independently from any count limit the auth might have. */
	eWarnIncreasinglyWithTimeLimit,		/** For Time-Limited Auths Only:
											Warn increasingly as the auth's required time limit approaches its end.
											Example: For a 64 day demo where the user ran the demo daily, warnings after
											the initial warning would occur on days: 32, 48, 56, 60, 62, 63 and 64. The   
											calulation used is: nextWarningDuration = (lastWarningTime - expirationTime) 
											* (parameter1 / parameter2), where parameter1 must be less than parameter2.
											The example can be accomplished by setting parameter1 to one and parameter2 
											to two.*/
	eWarnIncreasinglyWithCounter1Limit,	/** For Count-Limited Auths using the 32-bit counter 1 or the 64-bit counter 
											1 & 2 combo.  Warn increasingly as the auth's required count limit 
											approaches its end.  Example: For a 64 count down counter, warnings after the 
											initial warning would occur on counts: 32, 16, 8, 4, 2, 1. In warning  
											record, nextWarningCount = ( abs( lastWarningCount - expirationCount ) ) * 
											(parameter1 / parameter2), where parameter1 must be < parameter2.  The 
											example can be accomplished by setting parameter1 to one and parameter2 to 
											two. */
	eWarnIncreasinglyWithCounter2Limit,	/** For Count Limited Auths using the 32-bit counter 2.  This is meant for 
											eden modern locations only.  For auths other locations (iLok1), counter 2 
											does not exist.  As a result, auths in these other locations will only warn
											the first time.  Assuming counter 2 exists, the warning algorithm is the 
											same as described for eWarnIncreasingWithCounter1Limit, but uses counter 2. */
	eWarnIncreasingly,					/** This is a generic form of warning increasingly that does not specify the 
											limit to use in the algorithm.  The limit to use in the algorithm will be
											decided based on the limit actually attached to the auth.  If a time limit
											is attached to the auth, then the effective algorithms is 
											eWarnIncreasinglyWithTimeLimit.  If a count limit is attached to the auth
											then the effective algorithms is eWarnIncreasinglyWithCounter2Limit if 
											counter 2 is populated or eWarnIncreasinglyWithCounter1Limit if counter 2
											is not populated.*/
	eWarnIncreasinglyForSubscription,	/** This algrorithm is used for Subscription or NFR Subscription auths that have
											the refreshStartDays populated in the auth.  Parameter1 and parameter2 define
											the increasingly rate. The parameter 3 is set to the refreshStartDays.  The 
											parameter 4 is set to the gracePeriodDays. The attempts to refresh the 
											subscription won't start until the refreshStartDays plus gracePeriodDays before  
											the expiration.  If initial attempts to refresh the subscription fail, then 
											subsequent attempts will occur increasingly during the period defined by the 
											refreshStartDays.  Once the period defined by the gracePeriodDays is reached,
											then warnings happen at every launch of the protected product.  See the
											TimeLimitRecord structure for more details about refreshStartDays & 
											gracePeriodDays. */
}


//-----------------------
/**
AuthSituationType: These indicate the situations that can cause problems with auths on a location.  These problems  
				   are one of the reasons that an auth, matching the search criteria, is not valid (authorized).
				   Most of these AuthSituations occur during findAuths.  However, a few (where noted below) occur
				   during verifyAuth.
 */
enum eAuthSituationType
{
	eLostOrStolenAuthExpired = 0,	/** The user needs to connect to the Server to renew the strict parent, Lost Or 
										Stolen Auth. */
	eServerDisabledLocation,		/** The location is fraud locked probably because the it was reported as lost 
										or stolen. */
	eUnauthorizedSharedLocation,	/** There was an attempt to share the location across multiple computers/OSs.
										The user needs to unplug the iLok and reinsert the iLok to reset this. */
	eTamperedWithLocation,			/** The user should be told that there is a problem with the location and then
										directed to connect to the Server. */
	eNfrExpired,					/** The user needs to connect to the Server to renew a strict parent, NFR auth. */
	eComputerClockTurnedBack,		/** The computer clock has been turned back.  Either the user needs to correct
										the computer clock or connect to the Eden server to fixed the location that 
										thinks there is a clock problem.  This AuthSituation occurs during verifyAuth. */
	eLicenseDaemonNeedsUpdate,		/** An older license daemon is preventing the finding or verification of an auth.
										A newer License Daemon has to be installed to run the software.  This 
										AuthSituation can occur during verifyAuth. */
	eLocationNeedsUpdate,			/** The location needs to be connected to the Server for an update. */
	eInvalidDatabaseMachineBindings,/** The location needs to be connected to the Server for an update, because the
										its database has machine bindings that don't match the machine. */
	eSubscriptionAuthExpired,		/** A subscription auth with expired or not valid terms was found while 
										searching for auths. */
	eRemoteServerOffline,			/** A remote iLok Server that the user is setup to use is offline. 
										Since the server is offline, the kLicenseDbRemote location type along with
										RemoteServerInfo populated will be returned in the LocationData. */
	eSharedLicenseExpired,			/** A shared license with expired or not valid terms was found while searching
										for auths. */
	eRemoteServerBadPassword,		/** A bad password was provided to a remote iLok Server while searching for 
										auths.  Since the server access is limited without a password, the 
										kLicenseDbRemote location type along with RemoteServerInfo populated will be 
										returned in the LocationData. */
	eRemoteServerRequirementsNotMet,/** While searching for auths, it was detected that the client has not met an iLok 
										server's requirements.  Usually, the means that the client failed to provide
										information, such as name, phone and/or email address to the server.  Since the   
										server access is limited in thissituation, the kLicenseDbRemote location type   
										along with RemoteServerInfo populated will be returned in the LocationData. */
	eSharedLicenseNoLeaseAvailable,	/** A shared license has no more leases available.  This means that the maximum 
										number of clients are using the shared license, and no more clients can use the 
										shared license until a client with a lease gives up its lease.  This 
										AuthSituation occurs during verifyAuth. */
	eRelativeTimeDemoNeedsStarting,	/** An auth was found but is not authorized, because it has a relative time demo 
										that has not been started yet.  A relative time demo auth would be used in 
										pre-programmed iLoks at manufacture time.  The demo specifies a time period, 
										like 30 days. For a relative time demo to be considered authorized, it has to be  
										explicitly started.  So, if no valid auths to authorize a product are available,  
										then starting the relative time demo auth, indicated by this AuthSituation,   
										would allow the product to run until the demo runs out. */
}


//-----------------------
/** 
DeviceTypes:  This is an advanced specifier for a device location.
*/
enum eDeviceTypes
{
	kDeviceType_AllDevices =		0,		/** For searching, this indicates that all device types should be included
												This is NOT the norm for a search for AuthChains and Locations. */
	kDeviceType_CaIlok =			0x4341,	/** PACE Internal Use only.  These devices are NOT included in a standard search. */
	kDeviceType_FirmatarioIlok =	0x4649,	/** PACE Internal Use only.  These devices are NOT included in a standard search. */
	kDeviceType_StandardIlok =		0x5036,	/** USB Product ID for Standard iLok1 and iLok2 devices.  These devices are 
												included in a standard search. */
	kDeviceType_PmdIlok =			0x5052,	/** PACE Internal Use only.  These devices are NOT included in a standard search. */
	kDeviceType_SignatoryIlok =		0x5349,	/** PACE Internal Use only.  These devices are NOT included in a standard search. */
}


//-----------------------
/** 
CounterType: This is the type of counter in a CountLimitRecord.
*/
enum eCounterType 
{
	eCounterType_NotUsable = 0,					 /** Counter is not usable. */	
	eCounterType_StandardNonAutoAdvance,		 /** Counter does not auto advance, and must be advanced manually. */	
	eCounterType_AutoAdvancesForCryptoOperation, /** Counter auto advances for each crypto operation, such as auth 
													 verification (including fusion license checks), content key 
													 generation, signing, etc. */
	eCounterType_AutoAdvancesForProductLaunches, /** Counter auto advances for each auth verification that is designated  
													 as a product launch (when the cacheTheProductLocationData is set to
													 true in the VerifyAuthOptions). */
}

//-----------------------
/** 
AuthRanking: These ranking values applied to auths.  A higher number means the auth has a higher ranking.  By default
			 callers should always try to verify the highest ranking auths first.  Callers can instead choose to rank
			 auths different.  Except for the values defined here, auth ranking values are subject to change and are 
			 based on an algorithm in the License Daemon Service when finding auths.  After verifying an auth, the auth  
			 ranking values may change in the AuthData due to an algorithm difference between the License Daemon Service
			 and the PACE Eden Library.
*/
enum eAuthRanking 
{
	kAuthRanking_NotValid = 0,					 /** An expired, inactive or misconfigured auth will get this ranking. */	
	kAuthRanking_NotValidNowButWillBe = 1,		 /** An auth that is currently not valid but will be will get this ranking. */	
	kAuthRanking_MinimumValidRanking = 2,		 /** An auth that is valid will have this ranking or higher. */	
}


//-----------------------
/** Constants for AuthChains. */
const i32 kMaximumAuthsPerChain = 100


//-----------------------
/** Constants for undefined numbers. */
const i32 kUndefined32 = -1			// 0xFFFFFFFF
const i32 kUnknownAlgorithm = -1	// 0xFFFFFFFF
const i64 kUndefined64 = -1			// 0xFFFFFFFFFFFFFFFF


//----------------------- /** Constants for a location's authGaugePercentFull. */
const i32 kAuthGaugeFull			= 100	/** The location is completely filled with auths. */
const i32 kAuthGaugeEmpty			= 0		/** The location contains no auths. */
const i32 kAuthGaugeNotApplicable	= -1	/** The Auth gauge is not applicable to the location.  For example a license 
												database has no set auth capacity. */
const i32 kAuthGaugeNotAvailable	= -2	/** The Auth gauge is not available.  A server connection will be required  
												to get the actual auth gauge information in this case. */
const i32 kAuthGaugeNotRequested	= -3	/** The Auth gauge was not requested by the caller. */


//-----------------------
/** StorageID Constants for TimeLimitRecords. */
const i64 kStorageId_StandardTimeLimit   	= 0x80000000 /** This storageId is for the standard auth time limit. The
															 current date & time must be within time limit for the
															 executable/content to be licensed and usable. */		

const i32 kStorageId_ReleaseDateTimeLimit 	= -2147483646 /** (0x80000002) This storageId is for a time limit that  
															 restricts the licensing of executables/content based on the   
															 release date of the executables/content.  An 
															 executable/content release date must be within the time   
															 limit for the executable/content to be licensed and usable.
															 This time limit is not related to the current date & time.*/		

//-----------------------
/** StorageID Constants for CountLimitRecords. */
const i64 kStorageId_StandardCountLimit   	= 0x80000000 /** This storageId is for the standard auth count limit. The
															 executable/content is licensed and usable until the count
															 runs out. */		

//-----------------------
/** StorageID Constants for DeveloperDataRecord. */
const i32 kStorageId_LegacyDeveloperData  	= 1			/** This storageId is used to get the entire Legacy Developer Data.
															This data is what would be found in an iLok1 auth including the
															all of the legacy tokens 0 through 63.  However, if the auth 
															contains an iLok1-style time or count limit, then the data for
															this limit will be zeroed.  This data is available from any 
															locations. */
	/** Important:	More storage on Eden modern locations like iLok2 and the License Database will eventually be made 
					available to developers.  If you need such storage, please consult with PACE before you try to use the 
					LegacyDeveloperData, since the LegacyDeveloperData, from the InterLok era, is being phased out.  Legacy
					Tokens 56, 57, 58 and 59 will continue to be supported, since these tokens do not conflict with iLok1's 
					time/count limits.  See the AuthAttributes and the AuthSearch and AuthData structures for more   
					information about Legacy Tokens support. */

// *******************************************************
// Auth Storage Records - These are records attached to auths.
// *******************************************************

//-----------------------
/** 
TimeLimitRecord:  This record represents a time limit.  Typically, a TimeLimitRecord is used to time limit the entire 
				  auth, but time limits can also be applied to portions of an auth or be used for other purposes.  
				  Time limits can also be used to trigger events in the life of an auth. Some time limits are not
				  with respect with the current time, but may be, for example, with respect to when a protected 
				  executable/content was released. TimeLimitRecords are identified by storageId values.  Some storageIds 
				  are reserved for standard purposes (see the "kStorageId_" constants above.  An ILok1 auth
				  can only handle one time limit, which is used for time limiting the use of the auth itself.  For other 
				  auth locations, multiple time limit records are possible.  The time period in a time limit is usually 
				  absolute (from this date/time to this other date/time).  Alternatively, a time period can be 
				  expressed in a relative time limit, like 30 days or 1 year.  However, while in relative format, the 
				  time limit has not been started yet and is not considered valid until started.  Once the relative time   
				  period has been started, then it will be converted to absolute start and stop dates.
*/
struct TimeLimitRecord
{
	//------------
	/** Record Identifier */
	1:	i32				storageId,			/** Storage identifier. */
	
	//------------
	/** Internal Reference:  If a record has been recently found, then this reference, in combination with location 
							 information, may be used to refind the same record quickly. */
	2:	list<byte>		internalReference,	/** For PACE internal use only: A temporary direct auth reference to the record. */

	//------------
	/** Time period */
	10:	string			startDate,			/** Start date of a license period (ISO 8601 format).  For a standard auth
												time limit, there is always a start date, but for iLok1 auths and 
												iLok1-style auths in iLok2, this date will drift forward as the 
												remaining time is decreased. For other time limits, if this string is ,
												empty, the time limit has no start date. */
	11:	string			stopDate,			/** Stop date of a license period (ISO 8601 format).  If this string is empty,
												the time limit has no stop date. */
	12:	i64				remainingSeconds,	/** Indicates the remaining seconds in the time limit.  Zero means the time 
												limit has expired, regardless of the current time.  For the release date
												limit and other limits not related to the current date, this value 
												should be ignored. */

	//------------
	/** Settings for Subscription related time limits only.  For the optional items, be sure to use the __isset. bool  
		to determine these optional items are populated.  These are optional because a LicenseD, that predates 
		subscription support, does not know to populate these settings. */
	15:	optional i32 refreshStartDays,	/** See explanation below */
	16:	optional i32 gracePeriodDays,	/** See explanation below */
	17:	optional bool isTimeToRefresh,	/** See explanation below */
	18:	optional bool inGracePeriod,	/** See explanation below */
	
	// Here is a diagram showing the the Subscription and NFR Subscription setting:
	
/** startDate...........................................................................................stopDate
    A                                         B                                   C                            D
    |                                         |<--       refreshStartDays      <--|<--    gracePeriodDays   <--|
    |--            Current period (month, quarter, year, etc.)                  --|                            |
    |--       isTimeToRefresh = false       --|--                      isTimeToRefresh = true...            
    |--                           inGracePeriod = false                         --|--  inGracePeriod = true  --|-- inGracePeriod = false
    |--                                              validNow = true                                         --|-- validNow = false... 
    |--        No refresh attempts here     --|--       Attempt to refresh here, warn if unsuccessful...
    |--          No warnings here           --|--     Warn increasingly here    --|--    Warn always here...
    
    A subscription auth has a time limit that is refreshed (moves forward) periodically.  A refresh is only allowed to
    happen if it is time to do the refresh and if the Eden server is set to continue the subscription.  If a user stops 
	paying for the subscription, then the continuation of the subscription refresh can be stopped by changing the
	setting on the Eden server.  When verifying a subscription auth, you will only have access to the current 
	subscription time limit (from point A to point D in the diagram).  The auth will only authorize your software 
	within this time limit.  This time limit must be refreshed for the user to run your software beyond the current
	subscription time limit.
	
	Point A is the startDate of the current subscription time limit.  Point D is the stopDate of the current 
	subscription time limit.  Point C is the stopDate minus the gracePeriodDays.  Point B is Point C minus 
	refreshStartDays.  There are handy flags, isTimeToRefresh and inGracePeriod, to tell you if it is time to do a 
	refresh and if you are in the grace period, respectively. 
    
	The current period (from point A to point C in the diagram) is typically the billing cycle for the subscription.
	For example, if the billing cycle is monthly, then the current period should be about a month.  Refreshing early 
	(before point C) or refreshing late (after point C) will affect the actual length of the next current period.  
	For a monthly subscription for example, the Eden server will adjust the next current period to target point C on 
	the same day of each month.  
	
	The gracePeriodDays is optional.  Its purpose is to keep your products running for users who are caught offline
	and can't refresh for an extended amount of time.  The advantage of the grace period is that it may keep your users
	happier by not having accidental down time.  In choosing the grace period length for your products, you have to  
	consider how long you are willing to let a user run your software without paying, because the next credit card 
	charge for the subscription could fail.
*/

	//------------
	/** Record Flags */
	20:	bool			relativeTime,		/** Indicates if the time limit is a relative time period and has not been 
												started yet. */
	21:	bool			validNow,			/** Indicates if the current time is outside of the time period, the 
												remainingSeconds is zero or relative time has not started yet. 
												For the release date limit and other limits not related to the current 
												date, this value should be ignored.
												*/
}


//-----------------------
/** 
CountLimitRecord:  This record represents a count limit.  Typically, a CountLimitRecord is used to count limit  
				   the entire auth, but count limits can also be applied to portions of an auth.  Count limits can   
				   also be used to trigger events in the life of an auth.  CountLimitRecords are identified by  
				   storageId values.  Some storageIds are reserved for standard purposes.  An ILok1 auth can only 
				   handle one count limit, which is used for count (launch) limiting the use of the auth itself.   
				   For other auth locations, multiple records are possible.
				   
				   Launch limit Warning: The 32-bit Counter 1 or the 64-bit combined Counter 1 & 2 always advance by 
				   one when the auth is verified.  This behavior, which is built into the iLok firmware, includes Fusion 
				   auth verifications.  So when using Fusion, these counters are not really launch counters.
				   When using Fusion under Eden, counter 2, as an independent 32-bit Counter, is setup to be the new
				   launch counter.  The wrapper will advance counter 2 at launch time, but Fusion never advances 
				   counter 2.  ILok1 auths do not have counter 2;  so only eden modern locations support true launch 
				   counters, when using Fusion protection.
*/

struct CountLimitRecord
{
	//------------
	/** Record Identifier */
	1:	i32		storageId,				/** Storage identifier. */
	
	//------------
	/** Internal Reference:  If this record has been recently found, then this reference, in combination with location 
							 information, may be used to refind the same record quickly. */
	2:	list<byte>	internalReference,	/** For PACE internal use only: A temporary direct auth reference to the record. */

	//------------
	/** Counter 1: All locations support this counter. */
	10:	bool	counter1Enabled,		/** Indicates if counter 1 is enabled.  This will be the same value as  
											counter2Enabled for the combined 64-bit counter. */
	11:	bool	counter1CountsUp,		/** Indicates if the count direction for counter 1 is up.  This will be the 
											same value as counter2CountsUp for a combined 64-bit counter . */
	12:	i32		counter1CurrentCount,	/** The current 32-bit unsigned count for counter 1. */
	13:	i32		counter1StartCount,		/** The starting 32-bit unsigned count for counter 1. */
	14: eCounterType counter1Type,		/**	This is the counter type for counter 1. */
	
	//------------
	/** Counter 2:*/
	20:	bool	counter2Enabled,		/** Indicates if counter 2 is enabled.  This will be the same value as
											counter1Enabled for the combined 64-bit counter. */
	21:	bool	counter2CountsUp,		/** Indicates if the count direction for counter 2 is up.  This will be the 
											same value as counter1CountsUp for the combined 64-bit counter. */
	22:	i32		counter2CurrentCount,	/** The current 32-bit unsigned count for counter 2. */
	23:	i32		counter2StartCount,		/** The starting 32-bit unsigned count for counter 2. */
	24: eCounterType counter2Type,		/**	This is the counter type for counter 2. */

	//------------
	/** Record Flags */
	29:	bool	hcpDemoLaunchCount = 0,	/** If true, then this counter is an old-style InterLok HCP Demo Launch Count.  
											Under Eden, the HCP Demo Launch Count are considered invalid.*/
	30:	bool	combined64BitCounter,	/** Both 32-bit unsigned counters are combined into one 64-bit unsigned counter, 
											where counter 1 is the most significant counter. */
	31:	bool	validNow,				/** Indicates if either counter 1 or counter 2 (if separate) or if the 64-bit 
											counter (if combined) has reached its end count. */
}


//-----------------------
/** 
DeveloperDataRecord:  This record represents unencrypted freeform data that is attached to an auth.  This data can be 
					  read-only or writable by the host computer.  If writable, there may be limitations associated 
					  with writing the data.  DeveloperDataRecords are identified by storageId values.  Some storageIds
					  are reserved for standard purposes.  An ILok1 auth has very limited amounts of developer data,
					  because most of the available storage is reserved for term limits.  For other auth locations, 
					  multiple records are possible.  A TimeLimitRecord and/or the CountLimitRecord with a storageId
					  matching this record can expire this record.  The data is still returned if the record is expired  
					  or not valid yet; so, it is up to the caller to enforce what it means for the developer
					  data to be invalid.
*/
struct DeveloperDataRecord
{
	//------------
	/** Record Identifier */
	1:	i32			storageId,			/** Storage identifier. */
	
	//------------
	/** Internal Reference:  If this record has been recently found, then this reference, in combination with location 
							 information, may be used to refind the same record quickly. */
	2:	list<byte>	internalReference,	/** For PACE internal use only: A temporary direct auth reference to the record. */

	//------------
	/** Data & its properties*/
	10:	list<byte>	data,				/** The developer data (not encrypted). */
	11:	i32			writeProperties,	/** This indicates the write properties of the data (see eWriteProperties). */
	12:	i32			dataSizeLimit,		/** This is the size limit for the data (useful when writing), but the actual 
											data size can be smaller. */

	//------------
	/** Record Flags */
	20:	bool		decryptOkay,		/** Indicates if this data can be involved in decrypt operations.  This may be 
											set to false for security reasons. */
	21:	bool		timeLimited,		/** Indicates if this data is time limited. */
	22:	bool		countLimited,		/** Indicates if this data is count limited. */
	23:	bool		validNow,			/** Indicates if a TimeLimitRecord or a CountLimitRecord with a matching  
											storageId is not valid yet or is expired, or there is a data problem with 
											the record.  This validity is for this record only and does not take the   
											overall state of the auth into account. */
}

//-----------------------
/** 
SecretDataRecord:  This record represents encrypted secret data that is attached to an auth.  This data is typically
				   read-only, however some secrets can be written by the host computer.  If writable, there may be  
				   limitations associated with writing the data.  The secret data itself may not be included in this 
				   record, like in the case of secret data from an iLok.  Records without secret data can only be 
				   referenced for use in PACE crypto functions.  SecretDataRecords are identified by storageId values.
				   Some storageIds are reserved for standard purposes.  An ILok1 auth only has a secret key that is 
				   used in proving that the auth is valid.  For other auth locations, multiple records are possible.  A 
				   TimeLimitRecord and/or the CountLimitRecord with a storageId matching this record can expire this 
				   record.  PACE crypto functions will reject the use of keys that are either expired or not valid yet.  
				   For secret data that is returned to the caller, it is up to the caller to enforce the use of the 
				   secret data that is either expired or not valid yet.
*/
struct SecretDataRecord
{
	//------------
	/** Record Identifier */
	1:	i32				storageId,		/**  Storage identifier. */

	//------------
	/** Internal Reference:  If this record has been recently found, then this reference, in combination with location 
							 information, may be used to refind the same record quickly. */
	2:	list<byte>	internalReference,	/** For PACE internal use only: A temporary direct auth reference to the record. */

	//------------
	/** Data & its properties */
	20:	list<byte>		secretData,		/** The encrypted secret data that can be used in crypto operations.  This data 
											always exists somewhere, but may not be available to callers here. */
	21:	list<byte>		nonceData,		/** This is optional nonce data that is needed to decrypt the secret data. */
	22:	i32				writeProperties,/** This indicates the write properties of the data (see eWriteProperties). */
	23:	i32				dataSizeLimit,	/** This is the size limit for the data (useful when writing), but the actual 
											data size can be smaller. */
	24:	eTypeOfSecret	typeOfSecret,	/** The identifier of the type of secret (see eTypeOfSecret). */
	25:	eAlgorithmId	algorithmId,	/** If applicable to the type of secret, this indicates the intended use 
											algorithm (see eEncryptionAlgorithmId & ePkStandardId). */
	26:	eEncryptionAlgorithmId encryptedWithId, /** Defines the encryption algorithm that was used to encrypt the secret data. */
	27:	i32				version,		/** This is the version of the secretData.  The version may affect how secretData 
											is interpreted. */
	
	//------------
	/** Record Flags */
	30:	bool			intendedUseOnly,/** Indicates if the secret may be used in its intended use only.  This may be
											set to true for security reasons.  If false, then the secret may be used as 
											a symmetric or assymetric key with any algorithm. */
	31:	bool			decryptOkay,	/** Indicates if the secret may be used in decrypt operations.  This may be set
											to false for security reasons. */
	32:	bool			timeLimited,	/** Indicates if this data is time limited. */
	33:	bool			countLimited,	/** Indicates if this data is count limited. */
	34:	bool			validNow,		/** Indicates if a TimeLimitRecord or a CountLimitRecord with a matching  
											storageId is not valid yet or is expired, or there is a data problem with 
											the record.  This validity is for this record only and does not take the   
											overall state of the auth into account. */
}


//-----------------------
/** 
AuthStorage:  Except for the standard TimeLimitRecord and CountLimitRecord that limit the auth itself, other storage
records attached to an auth are not returned in a standard auth search.  The caller must explicitly ask for the other 
records, since these other records not typical in auths.  The AuthStorage structure holds the results of storage record
searches returned to callers.

WARNING: The standard TimeLimitRecord and CountLimitRecord that limit the auth itself and the releaseTimeLimit for the
		 auth are never returned in AuthStorage. These record are instead returned as part of AuthData.
*/
struct AuthStorage
{	1:	list<TimeLimitRecord>		timeLimitRecords,	/** The TimeLimitRecords, if any, attached to an auth and found 
															in a record search. */
	2:	list<CountLimitRecord>		countLimitRecords,	/** The CountLimitRecords, if any, attached to an auth and found
															in a record search. */
	3:	list<DeveloperDataRecord>	devDataRecords,		/** The DeveloperDataRecords, if any, attached to an auth and 
															found in a record search. */
	4:	list<SecretDataRecord>		secretDataRecords,	/** The SecretDataRecords, if any, attached to an auth and 
															found in a record search. */
}



// *******************************************************
// Remote iLok Server & Client Structures
// *******************************************************

//-----------------------
/**
RemoteLicenseClient: This structure holds information about a client of a remote iLok Server.
 */
struct RemoteLicenseClient
{ 
	// User Info
	1:  string	userName,				/** User's first and last name */
	2:  string	userPhone,				/** User's phone */
	3:  string	userEmail,				/** User's email */
	4:  string	userLoginId,			/** User's login (for future use) */

	// Computer Info
	10: string	computerName,			/** The computer name */
	11: string	nodeName,				/** The network node name */
	12: string	osPlatform,				/** The operating system platform (Macintosh, Windows, etc.) */
	13: string	osSystemName,			/** The operating system name (Darwin, Windows 7, etc.) */
	14: string	osVersion,				/** The version if the operating system (10.8.0, 6.1.7600, etc.) */
	15: string	machineProcessor,		/** The type of machine/processor (x86_64, x86, etc.) */
	16: string	locale,					/** The client computer's locale (es_us, etc.) */
	17: i32		utcOffsetSeconds,		/** The client computer's offest from GMT in seconds (-28800, etc.) */
	18: string	ipAddresses,			/** The ipv4 and ipv6 addresses of the client computer. */
	
	// Client Identifiers
	20: i64		computerId,				/** This is a client identifier that is randomly created and stored in the  
											client database.  Although it is not guaranteed, this identifier is  
											extremely likely to be unique among iLok Server clients and servers. */
	21: i64		licenseD_Pid,			/** The process ID of the LicenseD running on the client computer. */
	
	// Communications Channel Info 
	30: i32		channelId,				/** Communications channel identifier. */
	31: i64		auxChannelId,			/** Auxiliary communications channel identifier. */
	32: string	channelEstablishedTime, /** The GMT date/time that the channel was established. */
}


//-----------------------
/**
RemoteServerInfo: Information about a remote iLok Server, which may host one or more remote 
				  locations.  Auths that don't allow sharing (where the kSharedLicense attribute is not set) will not 
				  be considered authorized on a remote location. 
*/
struct RemoteServerInfo
{
	//------------
	/** Server Identifiers */
	1: string		name,				/** Server name set by server administrators.. */
	2: string		host,				/** Server network host, typically an IP address, but can be a name that will 
											resolve to an IP address. */
	3: i32			port,				/** Server port number, which is typically 31400. */
	4: i64			computerId,			/** This is a server identifier that is randomly created and stored in the  
											server's client database.  Although it is not guaranteed, this identifier is  
											extremely likely to be unique among iLok Server clients and servers. */
	5: list<byte>	internalReference,	/** For PACE internal use only. */
	6: string		serialNumberGuid	/** This is the serial number guid of the remote iLok Server.  If the remote 
											license server has never connected to the Eden server, then this will be 
											empty. */

	//------------
	/** Server Version Info */
	10:	string	licenseDaemonEdenVersion,			/** For LicenseD, this is the major Eden version string.  This will
														be set to "Unknown"for a LicenseD released before December 2012. */
	11:	string	licenseDaemonEdenRevision,			/** For LicenseD, this is the Eden revision string ("r12847", for  
														example), which is really the Eden build number.  If no numbers  
														follow the "r", then you are not using an officially released 
														build of LicenseD.  This will be set to "Unknown" with no "r"  
														for a LicenseD released before December 2012. */
	12:	i32		licenseDaemonAuthServiceVersion,	/** For LicenseD, this is the Authorization Service Version.  If the 
														libraryAuthServiceVersion and licenseDaemonAuthServiceVersion match, 
														then the PACE Eden library & LicenseD were built with the exact same 
														interface to talk to each other.  If these versions differ, then  
														the interfaces may have differences, but in general a newer 
														LicenseD will be compatible with an older library.  However, if  
														the library is newer that LicenseD and if the library is using 
														a feature that is not in the older LicenseD, then LicenseD will 
														have to be updated.  The library release notes should cover any 
														LicenseD version incompatibilies.  If zero is returned as the 
														version, then an Eden version of LicenseD is NOT running or 
														installed.  LicenseD version shipped with fusion HYBRID will
														also return a version of zero.  If nonzero is returned, then
														an Eden version of LicenseD is installed. */
														
														
	//------------
	/** Administrator Contact Info */
	20: string		adminName,				/** Administrator name. */
	21: string		adminPhone,				/** Administrator phone number. */
	22: string		adminEmail,				/** Administrator email address. */
	

	//------------
	/** Lease Settings */
	30: i32			leaseExpirationMinutes = 0, /** This is the time period that the server will allow the client to hold a  
													lease following an auth verification by the client.  Clients are 
													expected to do auth verifications more frequently than this period. 
													Zero means that this setting is unknown. */
}
	  

//-----------------------
/**
SharedLicenseInfo: Information about the shared license (authChain) and the caller's lease (use of) the shared license
				   from a remote iLok Server. 
*/
struct SharedLicenseInfo
{
	//------------
	/** Lease Info - Information about the caller's lease (use) of a shared license seat.  A shared license (authChain) 
					 will allow some number of concurrent users to share the license.  The number of concurrent user's  
					 is the number of seats allowed by the shared license.  A lease is sometimes called a floating 
					 license, because the leases can move around from user to user as long as the number of concurrent 
					 users does not exceed the number of seats. */
					 
	1: i64			leaseId = 0,			/** ID for the lease.  Zero means that the calling process currently has 
												no lease. Nonzero means the calling process has a lease. */
	2: string		leaseExpiration,		/** When an active lease is going to expire assuming it is not extended or 
												when an expired lease did expire.*/
	3: string		leaseCreation,			/** When an active lease was first created. */

	//------------
	/** Seat Info - Information about the seats of the shared license.  */
	10: i32			dRightTotalSeats = 1,	/** The total seats available from the dRight on the Eden Server. These 
												seats can be allocated to one or more shared licenses (authChains).*/
	11: i32			authChainSeats = 1,		/** The number of seats allocated to this authChain.  This is the
												number of concurrent users that can share this authChain. */
	12: i32			seatAuthIndex = 0,		/** This index indicates which auth in the authChain holds the seats. 
												For individually shared auths, this index will be zero.  For shared  
												bundles (locked groups of auths), the index MAY be one or more, because 
												the seats MAY be anchored to the bundle auth in the authChain hierarchy.*/
	13: i32			seatsInUse = 0,			/** This is the number of seats in use for this authChain .*/
	
	//------------
	/** Security info. */
	20: list<byte>	securityInfo,			/** For PACE internal use only */
	21: i32			infoSize,				/** For PACE internal use only */
	22: i32			infoChecksum,			/** For PACE internal use only */
												
}


//-----------------------
/**
 RemoteLicenseServerRequirements: These are the requirements os a remote iLok Server.
 */
struct RemoteLicenseServerRequirements
{	
	1: bool requireClientPassword,			/** If true, then it is required that clients provide the clientPassword to use shared licenses on the remote iLok Server.*/
	2: bool requireServerStatsPassword,		/** If true, then it is required that clients (typically server administators) provide the serverStatsPassword to   
												access the remote iLok Server statistics information. */
	3: bool requireUserName,				/** If true, require that clients provide their name to use the remote iLok Server. */
	4: bool requireUserPhone,				/** If true, require that clients provide their phone number to use the remote iLok Server. */
	5: bool requireUserEmail,				/** If true, require that clients provide their email address to use the remote iLok Server. */
	6: bool okayToConnectAutomatically,		/** If true, then then client LicenseD will try to connect automatically to the remote iLok   
												Server.  If false, then the user has to explicitly connect to the server. */
	1000: optional string paceTestString,	/** This is for PACE internal use only. Do not set or interpret this value. */
}


//-----------------------
struct RemoteLicenseServerStatistics
{
	1: string startTime,					/** Date/time string when the server was started. */
	2: string stopTime,						/** If the server is not running, this is the date/time string when the server was stopped. */
	3: i32 totalClientConnections,			/** The total client connections made to the remote iLok Server, since the server started. */
	4: i32 totalNewLeasesIssued,			/** The total new leases issued, since the server started. */
	5: i32 totalLeasesExtended,				/** The total existing leases that were extended, since the server started. */
	6: i32 totalLeasesDenied,				/** The total leases denied to clients, since the server started. */
}


//-----------------------
/**
SharedLicenseStatSample: This structure holds a sample of information (statistics) about the usage of a shared license.
 */
struct SharedLicenseStatSample
{ 
	// Time period
	1:  string	startTime,		/** The time when the statistics included began */
	2:  string	stopTime,		/** The time when the statistics included ended */
	
	// Seats/Leases
	10: i32	minimumSeatsInUse,	/** Minimum number of lease (seats in-use) during the time period. */
	11: i32	maximumSeatsInUse,	/** Maximum number of lease (seats in-use) during the time period. */
	12: i32	authChainSeats,		/** The number of seats available for an authChain.  If the number changes during the 
									period, the largest number will be returned. */ 
	13: i32	leaseDenials,		/** The total number of times that a request for a lease was denied due to all the 
									seats being in use. */
	14: bool authorized,		/** Indicates if the Shared License was authorized as of the stopTime. */
	15: i32 usersDeniedLease,	/** The total number of users that were denied a lease due to all the
									seats being in use. */

}


// *******************************************************
// Auths
// *******************************************************

//-----------------------
/**
AuthSearch:  This structure defines the parameters that can be specifed to find auths in a licence database and on  
			 any connected iLok.  Be warned that iLok1s do not allow general searching of auths; so an authId must  
			 be specified to find an auth on an iLok1.  AuthSearch records are always constructed to find all authorized   
			 auths in all locations. The AuthSearch record initialization will not change.  Callers only need to modify
			 the items necessary to form the desired search criteria.
*/
struct AuthSearch
{
	//------------
	/** Auth Identifiers */

	/** Product Identifiers:  The combination of the first two identifiers uniquely identifies auths for 
							  a single product. */
	1:	i32			authId =		0,				/** A auth identifier for a product.  Zero means match any authId. 
														Must be nonzero to find auths in iLok1.*/
	2:	i32			publisherId =	0,				/** Publisher (owner) of the product.  Zero means match any publisherId. */
	3:	bool		matchUndefinedPublisherIds = 1,	/** Match auths that have undefined publisherIds.  You must set this   
														to true for ilok1Compatible auths (see WrapperAuthProduct).  If
														you don't, then any auth placed on an iLok2 before Eden (June 
														2013) or by Interlok Activation will not be found, because the auth's 
														publisherId will be  undefined (0xFFFFFFFF).  However, an iLok2 
														can be synchronized using ILM to get valid publisherIds   
														populated in all of an iLok2's auths.  If you set the authId
														to zero, the publisherId to your nonzero publisherId value and  
														the matchUndefinedPublisherIds to true, then be aware that you will 
														find all auths with undefined publisherIds, including auths from
														other publishers. */

	/** Auth Instance:  When multiple auths for the same product are at the same location (not supported on an iLok1), 
						then this instance is used to distinguish between them. */
	4:	i32			instance =		0,				/** An instance identifier for an auth at a given location. Zero
														means match any instance.  Any auth placed on an iLok2 before  
														Eden (June 2013) or by Interlok Activation will be undefined 
														(0xFFFFFFFF). However, an iLok2 can be synchronized using ILM    
														to get valid instances populated in all of an iLok2's auths. */

	/** Reserved Identifier */
	5:	i32			skuId_TBD =		0,				/** Reserved for future use.  Callers, please do not read or write this! */

	//------------
	/** Auth Characteristics */
	10:	eAuthType		authTypes =	 kAllAuthTypes,	/** Match auths with one or more authTypes.  OR together multiple 
														constants to express multiple items.  If you don't pass,
														kAllAuthTypes, then auths with undefined authTypes will not 
														be matched. */
	11:	eSubtype		subtypes =	 kAllSubtypes,	/** Match auths with one or more subtypes.  OR together multiple
														constants to express multiple items.  If you don't pass,
														kAllSubtypes, then auths with undefined subtypes will not 
														be matched. */
	12:	eAuthState		states =	 kAllStates,	/** Match auths with one or more AuthStates.  OR together multiple
														constants to express multiple items. */
	13:	eAuthAttributes	attributes = kAllAttributes,/** Match auths with one or more AuthAttributes.  OR together 
														multiple constants to express multiple items. */
	
	//------------
	/** Auth Locations */
	20:	eLocationType	locationTypes = kAllLocationTypes,	/** Match auths at one or more AuthLocations.  OR together 
																multiple constants to express multiple items.  The
																default is setup to find all locations.  For future-
																proofing your code, it is best to use the locationGroup
																to limit the location types that you want to search.
																Otherwise you will have to update your software whenever
																a new location is released by PACE. */
	21: eLocationGroup	locationGroup = eLocationGroup.eUseLocationTypes,	
															/** As a better alternative to using locationTypes, locationGroup 
																allows callers to specify locations by abstract groups that
																will be automatically updated in the field as future 
																locations are released by PACE.  Typically, locationGroup  
																is set to validLocations returned by the 
																getProductInfoFromLicenseData function.  If you are 
																finding subscription auths to refresh, then use
																eAcceptableLocations_LocalOnly_All, because you can only
																refresh local locations.  See the ValidLocations section
																below for other valid constants to set locationGroup. */
	22:	i64				serialNumber = 0,					/** Match auths at the given location having this serial number. 
																Zero means match a location with any serial number. */
	23:	string			serialNumberGuid,					/** Same as serialNumber, but some locations have a string 
																form instead of the number form.  Leave empty to match any. */

	//------------
	/** Advanced Location Specifiers */
	30:	list<eDeviceTypes>	deviceTypes,		/** Do not set this, unless you really know what you are doing.  Leaving  
													this empty will cause only standard locations to be searched. */

	//------------
	/** Auth Search Options */
	40:	bool		includeChainsAuthorized = 1,	/** If true, include, in the search, chains that will authorize a product. */
	41:	bool		includeChainsNotAuthorized = 0,	/** If true, include, in the search, chains that will NOT authorize a product. */
}


//-----------------------
/**
ActivationInfoRecord: This contains activation information associated with the auth.  Since this information is stored
					  in the License Database, this information may or may not be available for removable
					  locations like iLok.
*/
struct ActivationInfoRecord
{
	//------------
	/** Activation strings */ 
	1: string	activationDate,		/** The date that the auth was created in its current location. */
	2: string	depositDate,		/** The date that auth's asset was deposited into the user's account. */
	3: string	dRightGuid,			/** This is the reference to the auth's asset in the user's account. */
	4: string	dRightName,			/** This is the name associated with the dRightGuid. */
	5: i32		dRightRev = 0,		/** This is the revision string associated with the dRightGuid. */
	6: string	issuerReference,	/** This is an optional reference for the auth provided by the auth issuer (the 
										one who put the auth in the current location). */
	7: string	publisherReference,	/** This is an optional reference for the auth that is provided by publisher of the 
										product associated with the auth. */
	8: string	userAccount,		/** The user's Eden server account name that was used to activate the auth. */
	
	//------------
	/** Activation rules */ 
	20: eLocationGroup	acceptableLocations, /** This indicates the locations where the auth is allowed to be placed. */
	21: bool			transferAllowed,	/** Indicates if the auth can be transferred to another user's account. */
	22: bool			moveAllowed,		/** Indicates if the auth can be move to another location. */
}


//-----------------------
/**
AuthData: This is the core data that makes up an auth.  This data is returned for each auth found during an auth
		  search operation.  Auths can hold additional data that is not part of the core data.  This additional data 
		  is represented by storage records described in this file.  Once the caller receives the AuthData for an 
		  auth, this AuthData can be used to reference an exact auth in various operations.  These operations 
		  include reading and writing data in the auth's storage records, cryptographically verifying the auth 
		  and performing other cryptographic operations, like decryption, using the auth. 
*/
struct AuthData
{
	//------------
	/** Auth Identifiers */
	/** Product Auth Identifiers:  The combination of these two identifiers uniquely identifies auths for a 
								   single product. */
	1:	i32				authId,						/** An auth identifier for a product.  This is a non-zero number 
														that CANNOT be kUndefined32. */
	2:	i32				publisherId = kUndefined32,	/** A publisher (owner) identifier for a product.  This is a non-zero  
														that can be kUndefined32 if the location, like iLok1, does not
														support publisherIds. */

	/** Auth Instance:  When multiple auths for the same product are at the same location (not supported on an iLok1), 
						this instance is used to distinguish between them. */
	3:	i32				instance = kUndefined32,	/** An instance identifier for an auth at a given location.  This 
														is a non-zero number that can be kUndefined32, if the location, 
														like iLok1, does not support multiple instances of auths for 
														the same product on the same location. */

	/** Reserved identifier */
	4:	i32				skuId_TBD = kUndefined32,	/** Reserved for future use.  Callers, please do not read or write this! */

	/** Internal Reference:  If this auth has been recently found, then this reference, in combination with location 
							 information, may be used to refind the same auth quickly . */
	5:	list<byte>		internalReference,			/** For PACE internal use only: A temporary direct reference to the auth*/
	
	//------------
	/** Auth Characteristics */
	10:	eAuthType		authType,		/** The type of auth.  This may be kUndefined64, if the PACE software can't
											identify the authType. */
	11:	eSubtype		subtype,		/** The aubtype of the auth.  This may be kUndefined64, if the PACE software 
											can't identify the subtype. */
	12:	eAuthState		state,			/** The state of the auth. */
	13:	eAuthAttributes	attributes,		/** The attribute (there will be multiple) associated with the auth. */			

	14:	i32				authRanking,	/** A relative ranking of the auth, where a higher number is better, 
											to deal with multiple auths for the same product.  Zero means the
											auth is no longer authorized.  One means the auth is not valid now, 
											but will be.  Two to one hundred means the auth is authorized. */
	15:	i32				issuerId,		/** Typically, this identifies PACE as the issuer of the auth.  
											However, this could be a third-party issuer someday. */

	//------------
	/** Auth Terms */
	20:	bool	 hasTermsAtThisLevel,			/** Indicates if the auth has its own terms.  If not, the terms must be
													inheritied from the first ancestor auth that has its own terms. 
													See AuthChain for more details on auth hierarchy. */
													
	21:	bool	 doExpirationWarningCheck,		/** Indicates if an expiration warning check is warranted for this auth. */
	
	22: optional TimeLimitRecord	timeLimit,	/** If the auth is time limited, a TimeLimitRecord will be populated.  
													Use the __isset.timeLimit bool to determine if this optional 
													TimeLimitRecord is populated. This is the standard time limit for
													an auth.  An auth is only valid if the current time is within the
													date/time range of this time limit. */
													
	23: optional CountLimitRecord	countLimit,	/** If the auth is count limited, a CountLimitRecord will be populated. 
													Use the __isset.countLimit bool to determine if this optional 
													CountLimitRecord is populated. An auth is only valid if the enabled 
													counters in the CountLimitRecord have not reached zero. */
	24: optional TimeLimitRecord	releaseDateLimit,
												/** If the auth has a release date limit and IF REQUESTED BY THE CALLER
													in the VerifyAuthOptions for the verifyAuth function, this 
													TimeLimitRecord will be populated.  Only protected executables or 
													protected content released within the release date limit are allowed 
													to run. Initially, this new limit is not enforced by the PACE 
													wrapper or fusion callbacks. So, PACE Eden clients must enforce 
													this until wrapper and fusion start supporting this limit.  See the 
													fusion/wrapper documentation for about any support for this release 
													date limit. Use the __isset.releaseDateLimit bool to determine if this 
													optional TimeLimitRecord is populated.
													*******************************************************************
													WARNING: The releaseDateLimit will not be populated in the findAuth
													function until version 3.1.0 or later of License Support (LicenseD).
													If you are using version 3.1.0 or later of libpacefusion, then
													verifyAuth will populate the releaseDateLimit regardless of what
													License Support (LicenseD) version is used. 
													*******************************************************************
													*/
	//------------
	/** Auth names/strings:  For performance reasons, these are only returned, if specifically requested and then only 
							 returned if available.  For example, iLoks don't store this information; however this 
							 information may be available in the License Database.
							 WARNING: THIS INFORMATION MAY NOT ALWAYS BE AVAILABLE FOR AN AUTH! */
							 
	30: string	productName,				/** The name of the product. */
	31: string	publisherName,				/** The product's publisher name. */
	32: string	productCategoryName,		/** The category name (Application, Plugin, etc.)  of the product. */
	33: string	productMarketSegmentName,	/** The market segment name (Pro Audio, Games, etc.)  of the product. */
	34: string	description,				/** A description of the auth and/or the product associated with the auth. */
	35: string	productGuid,				/** The guid string for the product. */
	36: string	publisherGuid,				/** The guid string for the publisher. */

	//------------
	/** Auth Activation/Verification Info:  For performance reasons, this is only returned, if specifically requested   
										    and then only returned if available.*/ 
											
	40: optional ActivationInfoRecord activationInfo,	/** This is the optional activation info for a license, which is
															a group of one or more auths licensed together.  Only the
															topmost auth of each license (there is always one) will 
															returned activation info.  All auths that are the topmost 
															auth of a license, have the attribute of kNotLicensedWithParent. 
															Use the __isset.activationInfo bool to determine if this  
															optional ActivationInfoRecord is populated. 
									  WARNING (READ THIS!): THIS INFORMATION MAY NOT ALWAYS BE AVAILABLE FOR AN AUTH!
															Auths in a license that are not the topmost auths will not have this 
															information.  Also, iLoks do NOT store this information, but the  
															information may be available in the client database of the computer 
															where the iLok auth was activated.  Use authID and publisherId and  
															optionally instance for auth identification.  Do not use 
															activationInfo for auth identification since it is not always
															available! */
															
	41: string	lastVerificationDate,					/** The last date the auth was verified by the client software.  
															This may get purged periodically; so being empty doesn't 
															mean that the auth has never been verified. */
}


//-----------------------
/**
AuthChain:  When you deposit a license in a user's account, the license contains some number of auths.  The auths are 
			arranged in a hierarchy similar to derived C++ objects.  A child auth can inherit terms from its parent.  
			A parent auth can inherit terms from its parent (the grandparent), and so on.  The child auth, parent auth, 
			grandparent auth sequence forms an authChain.  If, for example, you activate a locked group license of 5  
			products to an iLok2, you are really activating 6 auths. One group auth that has the terms of the locked  
			group, and 5 child auths that represent the 5 products that you deposited.  Putting one copy of the term
			in the group auth instead of repeating the same terms in 5 auths saves space.  When this locked group  
			license is placed inside an iLok2, the auth hierarchy of the license is attached to an existing Master  
			Auth inside the iLok2.  The terms in the Master Auth are used to implement Lost Or Stolen (called TLC on 
			iLok.com).  Let us say that one of the products in this locked license group is called MyCoolProduct.  So,  
			then when you search for MyCoolProduct using findAuths, you get this entire authChain: MyCoolProduct at 
			auths[0], Group Auth with the terms at auths[1], Master Auth at auths[2].  To determine if MyCoolProduct   
			is authorized or not, the entire AuthChain has to be checked and verified.  Because iLok1 does not support   
			this auth hierarchy, the effective terms are flattened down into each auth.  So, in the locked group license   
			example, iLok1 will have 5 auths the each have a copy of the terms.  ILok1 compatible auths in iLok2 
			are similarly flattened.
*/
struct AuthChain
{
	//------------
	/** The Auths in the AuthChain */
	1:	list<AuthData>	auths,			/** This holds a chain of auths starting with the target auth first (auths[0]),  
											the parent auth (if available) second (auths[1]), the grandparent auth (if 
											available) third (auths[2]), etc. */

	//------------
	/** AuthChain Characteristics */
	10:	bool			authorized,					/** Based on the complex auth hierachy rules that PACE code manages, this 
														indicates if the target auth in the chain is authorized or not. */
	11:	bool			relativeTimeNeedsStarting,	/** If the chain is not authorize, the reason may be that an unstarted 
														relative time limit is blocking the auth from being authoized. 
														The caller has to explicitly start the relative time limit 
														before the auth is considered authorized. */
	12:	i32				chainRanking,				/** A relative ranking of the chain, where a higher number is better,
														to deal with deciding which auth chain to verify when multiple 
														target auths are found for the same product. */
	13:	string			authChainVerificationTime,	/** This is only set by the verifyAuth functions, when an authChain
														is successfully verified.  The authChainVerificationTime 
														will not go backwards when the computer clock is set back.  
														Auth time limits are evaluated using this time. If this time
														has been accidentially been pushed into the future by setting 
														the computer in the future, verifying an auth and then setting 
														the computer clock back to the present, the Eden Server via the  
														Experience or the ILok License Manager can correct this time. 
														The eComputerClockTurnedBack authSituation is what triggers the 
														Experience to fix the authChainVerificationTime. */
	14:	string			computerTime,				/** This is the computer time when the authChainVerificationTime
														was computed, and is always returned when authChainVerificationTime
														is returned.  If authChainVerificationTime is later than 
														computerTime, then the clock has been turned back.  Since  
														network time corrections can legitimately set the time back a  
														bit if the computer clock runs fast, PACE code will not flag an 
														eComputerClockTurnedBack authSituation unless the clock has 
														been set back more than 5 minutes. */
	//------------
	/** AuthChain Location:  A location will have either a serialNumber or serialNumberGuid, but not both.  
							 The serialNumber will equal kUndefined64 if it does not exist, while
							 serialNumberGuid will be empty if it does not exist. */
	20:	eLocationType	locationType,				/** The location type from which the AuthChain came. */
	21:	i64				serialNumber = kUndefined64,/** The serial number of the given location. */
	22:	string			serialNumberGuid,			/** Same as serialNumber, but some locations have a string Guid form 
														instead of a number form. */
	23: bool			remoteLocation = 0,			/** Deprecated: Use .__isset.remoteServer instead. */
	24: i32				overseerId,					/** This is the publisher ID that oversees the target auth.  This is 
														usually PACE's Publisher ID. */
	25:	optional RemoteServerInfo remoteServer,		/** If populated (.__isset.remoteServer is true), then 
														the location is from a remote location, and the information 
														here identifies the remote iLok Server that is hosting the  
														remote location. */
	
	//------------
	// Advanced Location Specifiers
	30: eDeviceTypes	deviceType = 0,				/** This is a non-zero device type, if the location has a device 
														type.  This is zero otherwise. */
	31: bool			standardLocation,			/** True if the location is a standard location (based on the 
														deviceType); false if not standard. */

	//------------
	/** AuthChain Compatibility:  These parameters help with future locations that are backwards compatible with 
								  present day locations.  For example, if iLok3 is released with a new location value  
								  and if iLok3 contains iLok2-compatible AuthChains that can be verified with  
								  iLok2-compatible USB commands, then the parameters below will help the authVerify 
								  function, which only knows how to verify iLok2 AuthChains in older software, can 
								  verify iLok3 AuthChains using iLok2-compatible USB commands. */
	40:	eLocationType	authCompatibleLocationType = 0,	/** If non-zero, then the AuthChain is compatible with auths 
															found with this alternate location type. */
	41:	list<byte>		authCompatibleInternalRef,		/** For PACE internal use only:  An internal reference that will 
															help older software connect to future locations. */
															
	//------------
	// Shared License Information - Only available for shared licenses (AuthChain).
															
	50:	optional SharedLicenseInfo sharedLicenseInfo,				/** If populated (.__isset.sharedLicenseInfo is true), 
																		then this is the shared license info for this 
																		authChain.  */
	// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -   
	// Warning: The shared license information below may require the client to provide a server stats password for 
	//			access.  If required, this password must be set in the iLok Server client preferences.  Furthermore,
	//			if you want this information to be populated by the findAuths function, then you must set 
	//			includeRemoteServerStats to true in the FindAuthOptions.  The verifyAuth function will not get or 
	//			refresh this information in any authChain verified by this verifyAuth.
	// -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  
	
	51:	optional list<SharedLicenseStatSample>	sharedLicenseStats, /** This is a collection of statistics samples. 
																		Each sample is usually taken at the start of 
																		each hour and covers data collected over the 
																		the previous hour; however, each sample defines  
																		its real time period for the sample. Samples are  
																		provided in chronological order.  Use the 
																		__isset.sharedLicenseStats bool to determine 
																		if this optional data is populated. The list
																		may be empty, even if the __isset is true. */ 

	52:	optional list<RemoteLicenseClient>	clientsWithCurrentLeases,/** These are the client that currently have leases
																		 (a floating license or seat that is in-use on  
																		 an iLok Server) for this license (AuthChain).  
																		 Use the __isset.clientsWithLeases bool to 
																		 determine  if this optional data is populated. 
																		 The list may be empty, even if the __isset is 
																		 true. */ 
}


//-----------------------
/**
AuthProduct:  As a convenience, this combines an authId and a publisherId.  This combination is required in order to 
			  uniquely identify a product for auths that are not iLok1 compatible.
*/
struct AuthProduct
{ 
	1:	i32				authId,						/** An auth identifier for a product.  This is a non-zero number 
														that CANNOT be kUndefined32. */
	2:	i32				publisherId = kUndefined32,	/** A publisher (owner) identifier for a product.  This is a non-zero  
														that can be kUndefined32 if the location, like iLok1, does not
														support publisherIds. */
}


// *******************************************************
// ErrorInfo for the PACE Eden Interface
// *******************************************************
/**
 This is the result information that is returned by the PACE Eden Interface functions.
 */

enum eErrorNumber
{
	eNoError = 0,						/** This means that the function executed successfully without error. */
	eOperationStartError = 1,			/** This means that an Activation Services operation could not be started. */
	eOperationAccessError = 2,			/** This means there was an error trying to access an operation. Probably because the handle is invalid. */
	eOperationInProgress = 3,			/** This means you tried to get a result for an operation that is still in progress. */
	eCollectionAccessError = 4,			/** This means that an invalid handle value was provided to look up an Activation or Authorization collection. */
	eOperationException = 5,			/** This means that an Activation Services operation caught an exception. */
	eOperationFailed = 6,				/** This means that an Activation Services operation failed for some unkknown reason */
	eOperatioStopped = 7,				/** This means that an Activation Services operation was stopped. */
	eOperationServiceUnavailable = 8,	/** This means that the Activation Services server is unavailable. */
	eOperationCalledTooSoon = 9,		/** This means that the Activation Services has a minimum interval between calls of this type and you called too soon. */

  /**
  This value can be used to define your own error number values if you want to use our ErrorInfo structure to
  carry error information for your PaceEden API app. All PACE error numbers are guaranteed to be less than
  eFirsPublisherErrorNumber. If you hapen to write software that uses this feature, and you somehow interact with
  software from a different publisher that also uses this feature, you may need to coordinate your usage. But
  we guarantee that we won't step on your values.
  */ 
	eFirstPublisherErrorNumber	= 10001			/** This can be used to define your own errors that do not interfere with PACE defined errors.*/
}

struct ErrorInfo
{
	1: i32			errorNumber,		/** Zero means no error.  A non-zero code, which is specific to the error class, 
											means there was an error. */
	2: string		errorName,			/** This is the error name matching the code. */
	3: string		errorClass,			/** This is the error class to which the code/name belongs. */
	4: string		errorDescription,	/** If available, this is the description of the error. */
}


// *******************************************************
// Expiration Warnings
// *******************************************************
//-----------------------
/**
ExpirationWarning:	This record contains information about warning a user of an upcoming expiration for an auth.  The 
					warning information is stored in the License Database regardless of where the auth is located, and 
					there is one record for each auth.  If you have multiple  apps with different warning algorithms 
					using the same limited auth, then a warning  presented in the one app will update the state of the
					last warning in the record shared by both apps.  Both app will then continue using the updated 
					state of the last warning in the shared record for there calculations for the next warning.  For 
					more information about auth time limits and count limits, see the TimeLimitRecord and 
					CountLimitRecord structures in this file.   For more information about the warning algorithms,
					see the eExpirationWarningAlgorithm	enums in this file.
*/
struct ExpirationWarning
{
	//------------
	/** Warning Rules */
	1: eExpirationWarningAlgorithm	algorithmId = eExpirationWarningAlgorithm.eWarnNotApplicable, /** This is the algorithm used for determining when 
																		  to warn a user about an upcoming expiration. */
																		  
	/** If any of these parameters are unused for an algorithm, these unused parameters must be set to zero! */
	2: i32		parameter1 = 0,		/** The first paramter which may or may not be used in the warning algorithm. */
	3: i32		parameter2 = 0,		/** The second paramter which may or may not be used in the warning algorithm. */
	4: i32		parameter3 = 0,		/** The third paramter which may or may not be used in the warning algorithm. */
	5: i32		parameter4 = 0,		/** The forth paramter which may or may not be used in the warning algorithm. */
	
	//------------
	/** Warning States */
	10: bool	globalWarning = 0				/** This indicates that this record requires the global warning    
													mechanism.  This is for auths high up in the auth hierarchy that  
													will eventually expire many children auths. */
	11: string	lastWarningDate,				/** If set to the constant kLastWarningDate_NoWarningYet, then no 
													warning has occurred yet. Otherwise, this indicates that last
													warning date. */
	// 12: i64	currentCounter = 0				/** No longer used after DP1. */
	// 13: i64	nextCounter = 0					/** No longer used after DP1. */
	14:	string	internalReference,				/** For PACE internal use only.  A temporary direct reference to the 
													warning record. */
	// 15: string timeLimitStop,				/** No longer used after DP1.*/
	// 16: bool	isInitialWarningPeriod = 0,		/** No longer used after DP1. */
	17: bool	lostOrStolenAuthWarning = 0,	/** This indicates the warning to do is for the Lost Or Stolen Auth. 
													Lost Or Stolen is called TLC on iLok.com */
	// 18: bool	expiredAuth = 0,				/** No longer used after DP1. */
	19: bool	newAuthLimitDetected = 0,		/** If true, is a new time/count limit in the auth is detected. */
	20: bool	authorized = 0,					/** This indicates the auth associated with this record is authorized. */
	21: i32		launchesSinceLastWarning = 0,	/** The number of launches since the last warning.  For algorithms that 
													have no initial warning, this is the number of launches since a new
													limit was established (newAuthLimitDetected set to true).  This is 
													set to zero if it is time to do a warning 
													(when timeToDoWarning == true). */

	//------------
	/** Limits at the last warning: For PACE internal use only to keep track of when the next warning should occur 
									and when limits in the auth have changed.  Not all the field in these limits
									are preserved in the License Database.  Furthermore, those fields that are saved 
									may change over time. */
	28: optional TimeLimitRecord timeLimitLastWarning,	/** If the .__isset timeLimitLastWarning is true, then this has
															been populated with a partial copy of the TimeLimitRecord  
															from the auth or beta warning, when the last expiration 
															warning was performed. */
	29: optional CountLimitRecord countLimitLastWarning,/** If the .__isset countLimitLastWarning is true, then this has
															been populated with a partial copy of the CountLimitRecord  
															from the auth, when the last expiration warning was 
															performed. */
	//------------
	/** Main Warning Indicator */
	30: bool	timeToDoWarning = 0,			/** If true, the caller should warn the use about the upcoming 
													expiration. */
}

// Constant for lastWarningDate (above) that indicates that no warning has been done yet.
const string kLastWarningDate_NoWarningYet = "1970-01-01T00:00:00.000000Z"


// *******************************************************
// Locations
// *******************************************************

//-----------------------
/**
LocationSearch:	This allows callers to search for and get information about locations where auths can be stored.
*/
struct LocationSearch
{
	//------------
	/** Location Identifiers */
	1: eLocationType	locationTypes = kAllLocationTypes,	/** Match auths at one or more AuthLocations.  OR together 
																multiple constants to express multiple items. */
	2: eLocationGroup	locationGroup = eLocationGroup.eUseLocationTypes,	/** As an alternative to using locationTypes, locationGroup 
																allows callers to specify locations by abstract 
																groups that will be updated in the field as future 
																locations are created. */
	3:	i64				serialNumber = 0,	/** Match auths at the given location having this serial number.  Zero means
												match a location with any serial number. */
	4:	string			serialNumberGuid,	/** Same as serialNumber, but some locations have a string form instead of
												the number form.  Leave empty to match any. */

	//------------
	/** Advanced Location Specifiers */
	10:	list<eDeviceTypes>	deviceTypes,	/** Do not set this, unless you really know what you are doing.  Leaving  
												this empty will cause only standard locations to be searched. */
}


//-----------------------
/**
LocationData: This is information returned about a location found in a location search.
*/
struct LocationData
{
	//------------
	// Basic Information
	
	// Location Identifiers
	1: eLocationType	locationType,				/** Defines the location type. */
	2: i64				serialNumber = kUndefined64,/** The serial number of the given location, if available in number 
														form.  Otherwise this left set to kUndefined64. */
	3: string			serialNumberGuid,			/** The serial number of the given location, if available in GUID 
														form.  Otherwise this not set. */
	5: i32				overseerId,					/** This is the publisher ID that oversees the location.  This is 
														usually PACE's Publisher ID. */
	
	6:	optional RemoteServerInfo remoteServer,		/** If populated (.__isset.remoteServer is true), then 
														is identifying information for the iLok Server. */

	// Advanced Location Specifiers
	10: eDeviceTypes	deviceType = 0,		/** This is a non-zero device type, if the location has a device type.  
												This is zero otherwise. */
	11: bool			standardLocation,	/** True if the location is a standard location (based on the deviceType); 
												false if not standard. */
	
	//------------
	/** Extra Information:  This information requires extra accesses to the License Database and other caching
							systems to collect.  For performance reasons, this information is only returned if 
							specifically requested. */
							
	20: string	name,				/** The name of the location.  This should always be available, but will be a 
										default name, if the user has not set the name. */
	21: string	description,		/** The description of the location, if availble. */
	22: string	userAccount,		/** The user's Eden server account name that the location is associated.  Some 
										locations are not associated to a user specific. */
	23: string	dateRegistered,		/** The date that the location was first registered. */
	24: string	lastAuthChangeDate,	/** The last time an auth at the location was changed.  This is meant for clients, 
										like the ILok License Manager App, that need to know when to update a list of  
										auths in the UI.  Auths in locations, that were disconnected and then were 
										reconnected, are assumed to have change.  If lastAuthChangeDate has been
										requested but is empty, this means that the auths in the locations are currently
										being cached and that callers should wait until the caching is finished before
										attempting to update their list of auth in the UI. */
	25: i32	color = 0,				/** RGB color value associated with the location.  This color is not necessarily the
										actual color of the location (iLok, for example), but the color may be useful 
										for UI purposes. */
	26: optional string	lastLeaseChangeDate,
									/** For licenses on a remote iLok Server location only, this is the last time 
										that the number of leases (seats in use) for a shared license on the location changed.   
										This triggers apps, such as The iLok License Manager, to detect changes that
										require more indepth queries to the location. Use the 
										__isset.lastLeaseChangeDate bool to determine if this optional 
										lastLeaseChangeDate is populated. */
	
	
	//------------
	/** Detailed Information -	This information usually requires accesses to the location itself.  For performance
								reasons, this information is only returned if specifically requested.  Caller's 
								that are periodically polling locations can save time by only asking for the Detailed  
								Information initially and then only after lastAuthChangeDate changes in the Extra 
								Information. */
									  
	/** Location Status */
	30:	i32 authGaugePercentFull = kAuthGaugeNotRequested,	/** This indicates the percentage full of auths for the 
																location. */

	31: bool serverDisabledLocation = 0;					/** If true, the server has disabled this location.  This 
																typically is set to true if the server sees a location
																that was reported lost or stolen.  All auths on a 
																disabled location are considered invalid. */
																

	/** Zero Down Time (ZDT) and Lost Or Stolen (LOS) information.  Lost Or Stolen is called TLC on iLok.com*/
	40: bool locationSupportsZdtWithoutLos = 0;				/** If true, then this location is capable of supporting
																ZDT without LOS and PACE offers ZDT without LOS for this
																location. */
	41: bool locationSupportsLos = 0;						/** If true, then this location is capable of supporting
																LOS which always includes ZDT and PACE offers LOS for 
																this location. */
	42: bool zdtLosInfoIsStoredInTheLocation = 0;			/** If true, then the presence or absence of the time limits
																below indicate up-to-date coverage information.  If
																false, then the presence or absence does not necessarily
																indicate the presence or absence coverage, and any  
																coverage indicated may not be up to date. */
	43: optional TimeLimitRecord zdtSubscriptionPeriod;		/** This is the ZDT subscription period, which is typically 
																1 year.  If the losExpirationPeriod below is also 
																populated, then ZDT subscription period is also the LOS
																subscription period.  The subscription period is 
																informational and has no affect on the use of auths in 
																the location.  Use the __isset.zdtSubscriptionPeriod  
																bool to determine if this optional TimeLimitRecord is 
																populated. */
	44: optional TimeLimitRecord losExpirationPeriod;		/** This LOS expiration period, which is expires around 
																every 90 day or so, protects the user's auths in case
																the location is ever lost or stolen.  When this time
																limit expires, then every auth in the location will be
																considered invalid. As long as the location has not been
																lost or stolen, the user has to periodically connect to 
																the Eden server to renew this period during the 
																subscription period.  If the location is ever lost or
																stolen, then the location will eventually be disable
																by the time limit.  This gives PACE the freedom to
																replace the auths that were in the lost or stolen
																location.  Use the __isset.losExpirationPeriod  
																bool to determine if this optional TimeLimitRecord is 
																populated. */
	45: optional i32 romVersion;							/** If applicable to the location and if supported by 
																LicenseD, this is the base ROM version of the location.
																Use the __isset.romVersion bool to determine if this  
																optional romVersion is populated. */
	46: optional i32 patchVersion;							/** If applicable to the location and if supported by 
																LicenseD, this is the patch version of the location.
																Zero means that no patch is installed. Use the 
																__isset.patchVersion bool to determine if this optional
																patchVersion is populated. */
}


// *******************************************************
// Log Events 
// *******************************************************

//-----------------------
/**
eRemoteLicenseServerEventType: These define the type of remote iLok Server events for logging purposes.
 */
enum eRemoteLicenseServerEventType
{
	// Server Events
	eServerStarted = 0,			/** The remote iLok Server was started. */ 
	eServerStopped,				/** The remote iLok Server was stopped. */ 
	eServerPrefsUpdated,		/** The remote iLok Server preferences were updated. */ 
	eServerConfigExported,		/** The remote iLok Server configuration file for clients was exported. */ 
	eServerWarning,				/** A non-critical issue occurred on the server. */ 
	eServerError,				/** A critical issue occurred on the server. */ 
	
	// Client Events
	eClientConnected,			/** The client computer established a new communications channel to the remote iLok Server. */ 
	eClientReconnected,			/** The client computer reestablished its communications channel without disconnecting its old channel. */ 
	eClientDisconnected,		/** The client computer closed its communications channel with the remote iLok Server. */ 
	
	// Lease Events (A lease is sometimes called a floating license.)
	eNewLease,					/** A new lease was granted to a client, using up a seat in the shared license. */ 
	eLeaseExtended,				/** An existing lease was extended for a client. */ 
	eLeaseExtensionDenied,		/** An existing lease could not be extended, because thelease count exceeded the lease count. */ 
	eLeaseExpiredDuringCheck,	/** An existing lease, which could not be extended, was found to be expired during the license check. */ 
	eLeaseReleased,				/** A lease was released, freeing up seat in the shared license. */ 
	eNoLeaseAvailable,			/** An attempt to get a new lease failed, because the maximum number of leases (seats) is currently in use. */ 

	// Shared Auth
	eSharedAuthRegistered,					/** A new shared auth was registered for use on the remote iLok Server. */ 
	eSharedAuthUpdated,						/** A previously registered shared auth had its seat info, terms or other significant auth info updated. */ 
	eSharedAuthNotAvailable,				/** A previously registered shared auth is not available on its location (detected after location updates). */ 
	eSharedAuthSampleStats,					/** A statistic sampling (typically covering an hour) is periodically taken on each shared license (auth).   
												This log event shows the the sampling results. */ 
	eSharedAuthSubscriptionOpenSessionFailed,/** Could not connect to the Eden server (OpenSession failed) for the purposes of refreshing subscription auths. */
	eSharedAuthSubscriptionRefreshed,		/** A previously registered subscription shared auth had its subscription refreshed (extended). */
	eSharedAuthSubscriptionFailedRefresh,	/** A previously registered subscription shared auth filed its subscription refresh. */	

	// Location Events (These are only logged for locations that contain shared licenses.)
	eLocationPluggedIn,			/** A location (iLok) was plugged into the remote iLok Server. */ 
	eLocationRegistered,		/** A new shared location was registered for use on the remote iLok Server. */ 
	eLocationUpdated,			/** One or more auths (Licenses) on this location were changed by the Eden server. */ 
	eLocationUnplugged,			/** A location (iLok) was unplugged from the remote iLok Server. */ 

	// AuthSituations Events (These are only logged if the client is searching for specific auths.  Logging is skipped for general searches, like ILM does.)
	eAuthSituationLostOrStolenAuthExpired,			/** A client, searching for auths, encountered eLostOrStolenAuthExpired. */ 
	eAuthSituationServerDisabledLocation,			/** A client, searching for auths, encountered eServerDisabledLocation. */ 
	eAuthSituationNfrExpired,						/** A client, searching for auths, encountered eNfrExpired. */ 
	eAuthSituationSubscriptionAuthExpired,			/** A client, searching for auths, encountered eSubscriptionAuthExpired. */ 
	eAuthSituationSharedLicenseExpired,				/** A client, searching for auths, encountered eSharedLicenseExpired. */ 
	eAuthSituationRemoteServerBadPassword,			/** A client, searching for auths, encountered eRemoteServerBadPassword. */ 
	eAuthSituationRemoteServerRequirementsNotMet,	/** A client, searching for auths, encountered eRemoteServerRequirementsNotMet. */ 
	eAuthSituationeRelativeTimeDemoNeedsStarting,	/** A client, searching for auths, encountered eRelativeTimeDemoNeedsStarting. */ 
}


//-----------------------
/**
SharedLicenseLogEvent:  This structure defines a remote iLok Server log event.
*/
struct SharedLicenseLogEvent
{ 
	// Common required event data 
	1: string							date,				/** Date and time of the event. */
	2: eRemoteLicenseServerEventType	type,				/** The event type. */
	3: string							description,		/** A description summarizing the specifics of the event without any client informtaion. */
	4: string							clientDescription,	/** A description of the client. This can be appended after the description, when it is  
																okay to disclose client information in the overall description put into a log. */

	// Targeted Auth - This is the auth that was targeted in a shared license operation. 
	10: optional AuthData				targetedAuth,		/** Check .__isset.auth to see is the auth is populated.*/
	
	// Seat Auth - This is the auth that holds the seat and terms information for the shared license.
	20: optional AuthData				seatAuth,			/** Check .__isset.auth to see is the auth is populated.*/
	
	// Client - Populated in events that involve a client only.
	30: optional RemoteLicenseClient	client,				/** Check .__isset.client to see is the auth is populated.*/
	
	// Error - Typically populated in eServerError events.
	40: optional ErrorInfo				errorInfo,			/** Check .__isset.errorInfo to see is the error info is populated.*/

	// Location - Populated in events that involve a shared location.
	50: optional LocationData			location,			/** Check .__isset.location to see is the location is populated.*/

	// SharedLicenseInfo/Lease - Populated in events that involve a shared licenses and/or leases.
	60: optional SharedLicenseInfo		sharedLicenseInfo,	/** Check .__isset.sharedLicenseInfo to see is the lease is populated.*/

	// Statistic sampling for a shared license.
	70: optional SharedLicenseStatSample statsSample,		/** Check .__isset.statsSample to see is the lease is populated.*/
}

//-----------------------
/**
 InstalledVersion:  This structure defines whether or not an Eden component is installed, and what version. */
struct InstalledVersion
{
	/** If false, then the component is not installed. */
	1:	bool	isInstalled = 0;
	
	/** If installed, this is the installed version of the component. */
	2:	string	version;
}

// *******************************************************
// Function Parameters 
// *******************************************************

//-----------------------
/**
 PaceEdenVersionInfo:	This is the version information returned by the getVersions function in the PACE Eden Interface
						(see PaceEden.h).  
 */
struct PaceEdenVersionInfo
{
	// Library Versions: This is the version information for the Fusion (Pace Eden) library to which your code is linked.
	1:	string	libraryEdenVersion,			/** For the library, this is the major Eden version string. */
	2:	string	libraryEdenRevision,		/** For the library, this is the Eden revision string ("r12847", for  
												example), which is really the Eden build number.  If no numbers follow 
												the "r", then you are not using an officially released build of the
												PACE Eden library. */
	3:	i32		libraryAuthServiceVersion,	/** For the library, this is the Authorization Service Version of this PACE  
												Eden library when it was built. */
	
	// License Daemon (LicenseD) Versions: This if the version information from the currently installed LicenseD.
	10:	string	licenseDaemonEdenVersion,			/** For LicenseD, this is the major Eden version string.  This will
														be set to "Unknown"for a LicenseD released before December 2012. */
	11:	string	licenseDaemonEdenRevision,			/** For LicenseD, this is the Eden revision string ("r12847", for  
														example), which is really the Eden build number.  If no numbers  
														follow the "r", then you are not using an officially released 
														build of LicenseD.  This will be set to "Unknown" with no "r"  
														for a LicenseD released before December 2012. */
	12:	i32		licenseDaemonAuthServiceVersion,	/** For LicenseD, this is the Authorization Service Version.  If the 
														libraryAuthServiceVersion and licenseDaemonAuthServiceVersion match, 
														then the PACE Eden library & LicenseD were built with the exact same 
														interface to talk to each other.  If these versions differ, then  
														the interfaces may have differences, but in general a newer 
														LicenseD will be compatible with an older library.  However, if  
														the library is newer that LicenseD and if the library is using 
														a feature that is not in the older LicenseD, then LicenseD will 
														have to be updated.  The library release notes should cover any 
														LicenseD version incompatibilies.  If zero is returned as the 
														version, then an Eden version of LicenseD is NOT running or 
														installed.  LicenseD version shipped with fusion HYBRID will
														also return a version of zero.  If nonzero is returned, then
														an Eden version of LicenseD is installed. */
	
	13: InstalledVersion experienceVersion,			/** Indicates if the activation experience framework is installed,
														and what version. For Eden SDK versions prior to 2.5.0, this
														structure will not be set. */
}


//-----------------------
/**
 FindAuthOptions:	Options for the findAuth functions.
 */
struct FindAuthOptions
{
	1: bool	sortChainsHighestRankingFirst = 1,			/** If true, then the AuthChains returned will be sorted so that the 
															ones with the highest chain ranking will be first in the list of 
															AuthChains.  This option is meant for the purposes of authorizing 
															a product.  The idea is that the highest ranking chain is the 
															most likely to verify successfully by the verifyAuth function.  
															For non-authorizing purposes, this sort option may not be useful. */
	2: bool	includeAuthNamesIfAvailable = 0,			/** If true, then the local database will be searched for the product 
															and publisher names associated with each auth.  This option is meant
															for displaying auths to users.  Because of the perfomance impact of
															looking up the auth names, this option should not be enabled when  
															searching for auths for the purposes of authorizing a product to
															run. */
	3: bool	includeActivationInfoIfAvailable = 0,		/** If true, then the local database will be searched for the
															activation info associated a each auth. Because of the 
															perfomance impact of looking up the activation information, 
															this option should not be enabled when searching for auths 
															for the purposes of authorizing a product to run. */
	4: bool updateLegacyTokenState = 0,					/** For some locations, legacy token support requires an extra 
															access to the location.  For better performance of callers 
															that do not use legacy tokens (the typical case), legacy  
															token support is bypassed by default.  If you are using 
															legacy tokens, then set this option to true to search for   
															and/or check the state of the legacy tokens.  This setting 
															only affects to the target auth[0] in an AuthChain.  Legacy
															tokens in parent auths are never updated. */
	5: bool includeSharedLicenseWhenLocalLicenseFound = 0,		
														/** If false (by default), findAuths will not look at iLok Server  
															servers to find a shared license (an auth on a remote iLok Server) 
															if a local auth is found.  If true, then findAuths will look 
															all at remote iLok Servers regardless of local auths found. */
																														
	10: eSearchMode	searchMode = eSearchMode.eNormal,	/** This specifies the search mode.  The eNormal search mode is 
															recommended. */


	20: bool includeRemoteServerStats = 0,				/** If false (by default), findAuths will not return the 
															sharedLicenseStats for each shared license found.  If true,  
															then findAuths return the sharedLicenseStats for each shared 
															license. */
	21:string statsBeginDate							/** If includeRemoteServerStats is set to true, then any
															any sharedLicenseStats samples collected before this date 
															will not be returned.  If an empty string (the default) is 
															provided, then no starting date limit is applied to the 
															sharedLicenseStats samples returned.
															*/
	22:string statsEndDate								/** If includeRemoteServerStats is set to true, then any
															any sharedLicenseStats samples collected after this date 
															will not be returned.  If an empty string (the default) is 
															provided, then no ending date limit is applied to the 
															sharedLicenseStats samples returned.
															*/
}


//-----------------------
/**
AuthSituation:   During the execution of the findAuths and verifyAuth functions, special situations may be detected 
				 that prevent a user from running their protected software.  As a result, this structure is used alert  
				 callers of these situations, so that an explanation and solution can be offered to users.
*/
struct AuthSituation
{
	// Core AuthSituation Data.
	1: eAuthSituationType situationType,				/** This indicates the type of situation that is occuring. */
	2: LocationData		  location,						/** This indicates the location where situation is occuring.   
															Only the Basic Information in LocationData will be returned. 
															Of locationType it zero, then no specific location is 
															involved in the authSituation.*/
	3: bool				  foundByFindAuths = 1,			/** This is true if the situation was detected by the FindAuths
															function.  This is the typical case.  Otherwise, the
															situation was discovered during the verifyAuth. */
															
	// The Auth Involved, if there is one involved in the AuthSituation.
	10: i32				  authId = 0,					/** If the sitation involves a single auth, this is the authId 
															of the auth.  This is zero otherwise. */
	11: i32				  publisherId = 0,				/** If the sitation involves a single auth, this is the publisherId  
															of the auth.  This is zero otherwise. */
	12: i32				  instance = 0,					/** If the sitation involves a single auth, this is the instance  
															of the auth.  This is zero otherwise. */
	13: optional AuthData auth,							/** This is optionally populate in LicenseD released mid-2014
															in situations where an auth is involved. */
															
}


//-----------------------
/**
 VerifyAuthOptions:	Options for the verifyAuth functions.  Most of these are advance options, and the default values
					should not be changed unless you really understand the verification process.
 */
struct VerifyAuthOptions 
{
	//------------
	// Critical - Must be set correctly by the caller for the verification to work correctly.
	1:	bool	derivedPrimaryAuthKey = 0,		/** For the Pace Eden Interface, this option will get overridden by the
													PaceEdenLicenseData.  So caller's using the Pace Eden Interface should 
													never bother setting this option.  For PACE internal code, this option 
													has to be set based on the PaceEdenLicenseData, FusionLicenseData or 
													ProtOptions.  Ultimately, the correct setting for this option comes 
													from the WrapConfig generated be the server. */
	2:	bool	verifyIsConsideredAProductLaunch = 1,
												/** If true, then the verify code will do all that is necessary to
													for a product launch.  For example, in a count limited auth, counter 
													2 if it exists and if it has been designated a launch counter will
													be advanced by one if this option is set to true.  The Eden wrapper
													will always set this to true, while all fusion callbacks (injected 
													or explicit) will always set this to false.  If you are using the 
													Pace Eden Interface, you have the choice of considering an auth 
													verification as a product launch or not.  If you are verifying an 
													auth multiple times during the use of your product, then you should 
													limit the setting of this option to true for just the first auth  
													verification only. This option will affect parent auths too; so be 
													very careful to set this option correctly. */

	3: bool getReleaseTimeLimit = 0,			/** If false (by default), verifyAuths will not look for a release
													time limit in each auth.  If true, findAuths will look for
													a release time limit in each auth and will return it with the auth  
													if found. */
	//------------
	// Optional - The caller can choose.
	10: bool	cacheTheProductLocationData = 1,/** If true, and if the auth verifies, the location and the auth's 
													product information will be cached in the local database.  This is 
													set to false in all Fusion auth checks for performance reasons.  
													This cached information allows UI, like the PACE Eden Experience, 
													to inform users about locations that are currently unplugged, but 
													have the previously seen auth that will authorize a protected product
													to run. The Eden wrapper will cache product information at launch.  
													If you are using the Pace Eden Interface, you have the choice with  
													this option of caching this information or not. */
	11: bool	updateAuthChainParents = 1,		/** If true, and if the auth verifies, the data of the parent auths in  
													ioAuthChain will be updated.  If false, then parent auths in  
													ioAuthChain will only be updated as needed for security reasons.
													The false option may save time; so this is set to false in all 
													Fusion auth checks. */
	12: bool	updateStandardTimeLocations = 1,/** Each time an auth is verified, the time when the auth is verified
													is stored, so that a user cannot turn the computer clock back.  If  
													this option is true, then the standard (preferable) locations are  
													used to store this data.  If false, then only special locations are  
													updated, as needed, to avoid local database commit locks.  The  
													commit locks for all Fusion auth checks are avoided, to prevent
													potential pauses within a fusion callback caused by server locks on
													the local database.  Other auth checks should update the standard 
													time locations, since such checks are generally not as time 
													critical as a fusion callback. */
	13: bool	updateLegacyTokenState = 0,		/** For some locations, legacy token support requires an extra access
													to the location.  For better performance of callers that do not
													use legacy tokens (the typical case), legacy token support is 
													bypassed by default.  If you are using legacy tokens, then set
													this option to true to securely check the state of the legacy 
													tokens.  This setting only affects to the target auth[0] in 
													an AuthChain.  Legacy tokens in parent auths are never updated. */
													
	//------------
	// Don't touch - Don't change the default unless directed by PACE to do so.
	20: i32		acceptableRootPublicKeyID = 0,	/** This is the minimum acceptable public key for verifying PACE 
													(Ilok2-based) certificate chains.  Use the default set here. */
}


// *******************************************************
// Demo Activation Support
// *******************************************************

//-----------------------
/**
 ActivationCodeType:	Enumerated values for the types of activation codes that PACE supports. These are more  
						functional definitions than they are types. For instance, we could have defined , 
						kActivationCodeTypeGuid but that's not as flexible as kActivationCodeTypeBakedInDemo, because  
						the latter lets the server decide how to interpret the string.
 */
enum ActivationCodeType
{
	kActivationCodeTypePukka		= 0,
	kActivationCodeTypeBakedInDemo,
}

//-----------------------
/**
 TypedActivationCode:	A structure that can carry different types of activation codes, with optional versioning.
 */
struct TypedActivationCode
{
	1:	string				codeValue = "",						 /** The activation code string. Could be a pukka code.  Could 
																	 be a GUID. Could be something we haven't thought of yet. */
	2:	ActivationCodeType	codeType = ActivationCodeType.kActivationCodeTypePukka, /** The code type. */
	3:	optional i32		codeVersion,						 /** Optional version information.  Use the 
																	 __isset.codeVersion bool to determine if this  
																	 optional i32 is populated. */
}

// *******************************************************
// Wrapper
// *******************************************************

//-----------------------
/**
 Platform definitions.
 */
const string kPlatform_Mac							= "mac"
const string kPlatform_Windows						= "windows"
const string kPlatform_Linux						= "linux"
const string kPlatform_AppleIos						= "appleIos"
const string kPlatform_ServerAny					= "server"


//-----------------------
/**
 Protection name constants. For now we only know about Eden.
 */
const string kProtectionName_Eden = "eden"


//-----------------------
/**
 ThriftDataIds: These IDs identify a persistent, flattened byte form of a thrift structure, so that the structure can  
				easily be identified before it is unflattened.   Since these values are in persistent structures, they
				can never change.
 */
const i32 kWrapInfoThriftDataId = 0x6f666e77,	/** Thrift data ID of a WrapInfo struct.  The value is actually 'wnfo' 
													in little endian. */

//-------
/** ValidLocations: The validLocations constants for WrapperPublicData.  These tell the wrapper, Fusion or any caller
					verifying an auth which locations are allowed to be searched for auths to verify.  These are
					the current eLocationGroup values that are supported by PACE (WrapConfigs, Wrapper, Fusion, etc.).
*/

// Local Only Constants- Does not allow shared licenses on remote iLok Servers.
const eLocationGroup eAcceptableLocations_LocalOnly_All =					eLocationGroup.eLocal_LocationGroup,				// Local only:  kIlok1, kIlok2, kIlok3 kLicenseDb, etc.
const eLocationGroup eAcceptableLocations_LocalOnly_Ilok =					eLocationGroup.eLocalIlok_LocationGroup,			// Local only:  kIlok1, kIlok2, kIlok3, etc.
const eLocationGroup eAcceptableLocations_LocalOnly_Ilok2orGreater =		eLocationGroup.eLocalEdenModernIlok_LocationGroup,	// Local only:  kIlok2, kIlok3, etc.
const eLocationGroup eAcceptableLocations_LocalOnly_AllButIlok1 =			eLocationGroup.eLocalEdenModern_LocationGroup,		// Local only:  kIlok2, kIlok3, kLicenseDb, etc

// Local or Remote Constants - Allows shared licenses on remote iLok Servers.
const eLocationGroup eAcceptableLocations_RemoteOrLocal_All =				eLocationGroup.eAllLocations_LocationGroup,			// Local or Remote: kIlok2Remote, kIlok3Remote, kIlok1, kIlok2, kIlok3, kLicenseDb, etc.
const eLocationGroup eAcceptableLocations_RemoteOrLocal_Ilok =				eLocationGroup.eIlok_LocationGroup,					// Local or Remote: kIlok2Remote, kIlok3Remote, kIlok1, kIlok2, kIlok3, etc.
const eLocationGroup eAcceptableLocations_RemoteOrLocal_Ilok2orGreater =	eLocationGroup.eEdenModernIlok_LocationGroup,		// Local or Remote: kIlok2Remote, kIlok3Remote, kIlok2, kIlok3, etc.
const eLocationGroup eAcceptableLocations_RemoteOrLocal_AllButIlok1 =		eLocationGroup.eEdenModern_LocationGroup,			// Local or Remote: kIlok2Remote, kIlok3Remote, kIlok2, kIlok3, kLicenseDb, etc

// Deprecated Constants, which are the same as the Local Only constants above.  Use the constants above.
//const eLocationGroup eAcceptableLocations_All =							eLocationGroup.eLocal_LocationGroup,				// Local kIlok1, kIlok2, kLicenseDb, etc.
//const eLocationGroup eAcceptableLocations_Ilok =							eLocationGroup.eLocalIlok_LocationGroup,			// Local kIlok1, kIlok2, etc.
//const eLocationGroup eAcceptableLocations_Ilok2orGreater =				eLocationGroup.eLocalEdenModernIlok_LocationGroup,	// Local kIlok2, etc.
//const eLocationGroup eAcceptableLocations_AllButIlok1 =					eLocationGroup.eLocalEdenModern_LocationGroup,		// Local kIlok2, kLicenseDb, etc


//-----------------------
/**
 WrapInfoVersion: Wrap info version numbers.
 */
enum WrapInfoVersion
{
	kWiVersion1 = 1,		/** The current version is 1. */
	kWiVersion2,			/** This version is reserved for future use. */
}


//-----------------------
/**
 Identity: Structure that defines a numeric and string based identity.
 */
struct Identity
{
	/** Numeric representation of the publisher or product. */
	1:	i32 id = 0,

	/** Optional PACE issued GUID of a publisher or product.  Use the __isset.guid  
		bool to determine if this optional string is populated. */
	2:	optional string guid,		

	/** Optional name of a publisher or product, if known.  Use the __isset.name  
		bool to determine if this optional string is populated. */
	3:	optional string name,		

	/** Optional type of identity (i.e. publisher, product, SKU, etc.).  Use the __isset.type
		bool to determine if this optional string is populated. */
	4:	optional string type,
}

/** Define a list of Identity structures. */
typedef list<Identity> IdentityList

//-----------------------
/**
 <p>
 Some method calls return a tree structure of identity nodes. But since Thrift does not allow recursive
 data structures, we can only represent children by index. So if children are specified in this returned 
 structure, they are actually zero based indices into the "nodes" of the list of structures returned.</p>
 <p>
 Unless otherwise specified, our APIs will return nodes in the following order:</p>
 <ol>
 <li>Standalone products (i.e. no parent and no children).</li>
 <li>Top level groups (i.e. no parent, but one or more children).</li>
 <li>Top level SKUs (i.e. no parent, but one or more children).</li>
 <li>Children (which may or may not have children themselves).</li>
 </ol>
 <p>
 To identify the top level standalone products or parents in any given provided list, all you have to do is
 loop until you reach the children, as indicated by the first node that has a parent set via the __isset.parent
 boolean.</p>
 <p>
 To access the children of any given parent node, all you have to do is loop through the children element
 list (if set as per the __isset.children boolean) in the parent and use the zero based indices there to
 access the corresponding IdentityNodes in the list that was provided to you.</p>
 <p>
 For example, if a call returns a single standalone product and two groups with two children each, you would 
 receive a list of 7 nodes, where the first one is a standalone product, followed 2 group nodes have no parent 
 but do have children, followed by the children themselves.</p>
 <p>
 Here's what such a tree might look like:</p>
 <pre><code>Index	Node		Parent Index	Children Indices
 -----	----		------------	----------------
 0	Product1	__isset false	__isset false
 1	Group1		__isset false	3,4
 2	Group2		__isset false	5,6
 3	Child1_G1	1		__isset false
 4	Child2_G1	1		__isset false
 5	Child1_G2	2		__isset false
 6	Child2_G2	2		__isset false
 </code></pre>
 */
struct IdentityNode
{
	/** Identifies of the product or group at this node level. */
	1:	Identity identity;
	
	/** If specified, then this node is a child and the integer value provided is the zero based index to the 
		parent. If not specified then this node is a top level node with no parent. */
	2:	optional i32 parent;

	/** If specified, this is a list of zero based indicies into a list of nodes that are children of this node. */
	3:	optional list<i32> children;
}

/** Define a "tree" of identities, which essentially is a list of IdentityNode structures. */
typedef list<IdentityNode> IdentityTree


//-----------------------
/**
 ProtectionInfo: Structure that provides information regarding the protection, when a signed binary was also protected.
 */
struct ProtectionInfo
{
	1:	string wrapperVersion,				/** The version of the protection applied to the binary. */
	2:	string wrapperRevision,				/** SVN revision number for the wrapper. */
	3:	string wrapConfigGuid,				/** TODO: [Allen] REDUNDANT! Needs fixing... */
	
	11:	string name = kProtectionName_Eden,	/** The name of the protection applied to the binary. */
	
	21:	bool isFusionProtected = 0,			/** Indicates if the binary is Fusion protected in addition to being wrapped. */
}


//-----------------------
/**
 PaceToolInfo: This structure defines indentification information for the PACE tool that performed a wrap or 
			   signing operation.
 */
struct PaceToolInfo
{
	1:	Identity id,		/** Identification information associated with the signing tool. */
	2:	string copyright,	/** Copyright string. */
	3:	string version,		/** Human readable version number for the tool. */
	4:	string revision,	/** SVN revision number for the tool. */
}


//-----------------------
/**
 WrapperAuthProduct:	This structure holds the public data for a single auth product.  WrapperPublicData holds one or more
						WrapperAuthProducts, representing all of the auths that can authorize a protected binary to run. 
 */
struct WrapperAuthProduct
{ 
	1:	i32					authId,					/** An auth identifier for a product.  This is a non-zero number 
														that CANNOT be kUndefined32. */
	2:	i32					publisherId,			/** A publisher (owner) identifier for a product.  This is a non-zero  
														that can be kUndefined32 if the location, like iLok1, does not
														support publisherIds. */
	3:	bool				ilok1Compatible,		/** If true, then authId is globally unique and publisherId is not 
														needed to identify the auth. */
	4:	bool				derivedPrimaryAuthKey,	/** If true, then the primary AuthKey is derived in iLok2 from 
														the authId and publisherId.  Derived keys save space in iLok2. */
	5:	string				productName,			/** The name of the product with which this auth is associated. */
}


//-----------------------
/**
 WrapperPublicData: This is developer public information that is part of a WrapConfig that is used in various places,  
					such as the Activation Experience.
*/
struct WrapperPublicData
{
	10:	bool noActivationCode = 0,									/** If true, then full activation only uses accounts, not 
																		activation codes. */
	11:	bool skipFloatingLicenseSetup = 0,							/** If true, skip display of the floating license setup page. */
	20:	eLocationGroup validLocations = eLocationGroup.eLocal_LocationGroup, /* Newest Thrift comnpiler won't let us use a constant here */
																	/** Indicates acceptable locations for finding auths. Can 
																		be used to force auth location limits, like iLok2-only
																		for higher security. */
	30: list<WrapperAuthProduct> productList,						/** List of one or more auth products that will enable 
																		the protected binary execution. */
	35: ExpirationWarning defaultExpirationWarningRules,			/** These are the default rules for doing expiration
																		warnings for auths that don't have defined rules
																		provided by the eden server.*/ 
	40:	optional list<byte> flattenedFailoverLicense,				/** Any "baked-in" failover license. If we're in a failover
																		situation and have not yet instanced the failover
																		license, then we can ask the License Daemon Service to 
																		save this failover license to the database.  Use the 
																		__isset.flattenedFailoverLicense bool to determine if 
																		this optional list of bytes is populated. */
	50:	optional list<byte> flattenedBlindDemoLicense,				/** Any "baked-in" blind demo software licenses. If we're
																		running unauthorized, but this optional object store
																		is set, then we can ask License Daemon Service to save 
																		the enclosed license data to the database, establishing 
																		a non-machine specific demo.  Use the
																		__isset.flattenedBlindDemoLicense  bool to determine
																		if this optional list of bytes is populated.  */
	60:	optional list<byte> flattenedIlok2BlindDemos,				/** If set, then the experience should use this to perform
																		a registered demo.  Use the __isset.flattenedIlok2BlindDemos  
																		bool to determine if this optional list of bytes is
																		populated. */
	70: optional TypedActivationCode registeredDemoActivationCode,	/** The baked in activation code for a registered demo.  Use 
																		the __isset.registeredDemoActivationCode bool to determine
																		if this optional TypedActivationCode is populated. */
}


//-----------------------
/**
WrapInfo: The wrapper info structure that is included in a wrapped executable. 
 */
struct WrapInfo
{
	1:	WrapInfoVersion version = WrapInfoVersion.kWiVersion1,			/** Version of the wrap info object. */
	2:	WrapInfoVersion minimumVersion = WrapInfoVersion.kWiVersion1,	/** Code that reads this structure must be at least this version  
															number or above to understand this structure. */
	
	11:	Identity wrapConfig,							/** Wrap configuration ID. */
	12:	Identity publisher,								/** Publisher name and ID. */
	13:	Identity product,								/** Product name and ID. */

	21:	ProtectionInfo protectionInfo,					/** Information regarding the protection. */
	22:	PaceToolInfo wraptoolInfo,						/** Information regarding the tool that performed the protection. */
	
	31:	string wrapInstanceGuid,						/** This is a guid that is randomly generated for each new wrap. */
	32:	string dateWrapped,								/** The date that the binary was wrapped in ISO 8601 string format. */
	
	40: optional WrapperPublicData wrapperPublicData,	/** Added in SDK 2.4.0 and will be populated going forward.   
															Use the __isset.wrapperPublicData bool to determine if 
															this optional structure is populated. */
}



// *******************************************************
// Dynamic Crypto Whitebox
// *******************************************************
//-----------------------
/**
 Dynamic Crypto Setup Input parameters. These are for use by whitebox generated code only.  PACE Engineers, please
 see the setupDynamicCryptoWhitebox function in PaceEden.cpp for details on these parameters. */
struct SetupDynamicCryptoWhiteboxInput
{
	1:	list<byte>	randomData,
}


//-----------------------
/**
 Dynamic Crypto Setup Output parameters.  These are for use by whitebox generated code only.  PACE Engineers, please
 see the setupDynamicCryptoWhitebox function in PaceEden.cpp for details on these parameters. */
struct SetupDynamicCryptoWhiteboxOutput
{
	1:	list<byte> communicationData,
	2:	list<byte> exchangeData,
	3:	list<byte> integralDomainData,
	4:	list<byte> contentData,

	10:	AuthChain authChain,				/** If a license is found, then this is the auth chain for the license used for Dynamic Crypto. */
	11:	list<AuthSituation> authSituations;	/** If non-empty these are problem situations that the caller may want to communicate to the user. */
}


// *******************************************************
// Activation Experience
// *******************************************************

//-----------------------
/**
 ActivationExperienceResult: This is the enumeration value that is returned from the Activation Experience.
 
 WARNING - Reordering these will break existing wrapped binaries. 
 */
enum ActivationResult_T
{
	ActivationResultCompleted	= 0,		/** At least one auth was successfully activated or deactivated, or a valid auth appeared during activation. */
	ActivationResultNeedNewerExperience,	/** The activation experience client is too new for the current 
												ActivationExperienceClientInterfaceVersion. */
	ActivationResultError,					/** An error occurred during the Activation Experience. */
	ActivationResultQuit,					/** The user quit the experience without activating. If the experience was 
												started to warn about a soon-to-expire auth, then this is returned 
												if the user does not activate an auth. */
	ActivationResultTry,					/** User wants to use the trial license. */
	ActivationResultSituationFixed,			/** We processed at least one AuthSituation, then found a valid auth.
												We did NOT attempt to verify the auth, so if the last situation we processed
												is one that is reported by verifyAuth, rather than findAuth, then a subsequent
												verify is not guaranteed to succeed. */
	ActivationResultNeedNewerDaemon,		/** The LicenseDaemon version needs to be upgraded. */
}

//-----------------------
/**
 ActivationExpInterfaceVersion_T: Enum that defines the version of the experience client interface. The verison may  
								  change because one of the structs used in the interface has changed, either at the
								  top level or at a lower level.  It may also be changed because the service definition
								  has changed.  The values here define the versions that exist so far.  The actual  
								  current version is defined in the ActivationExpInterfaceVersionInfo struct.
 */
enum ActivationExpInterfaceVersion_T
{
	ActivationExpInterfaceVersion1 = 1,
}

//-----------------------
/**
 ActivationExpInterfaceVersionInfo: Structure that carries the current Activation Experience version information.  
 */
struct ActivationExpInterfaceVersionInfo
{
	1: i32	version = ActivationExpInterfaceVersion_T.ActivationExpInterfaceVersion1,			/** The current version of the Activation Experience 
																									library interface. */
	2: i32	minimumVersion = ActivationExpInterfaceVersion_T.ActivationExpInterfaceVersion1,	/** This is the minimum version of the activation data 
																									that the activation library interface can handle. */
}

//-----------------------
/**
 ActivationExperienceResultParams:	This returns the result of an activate or deactivate operation, but is only directly 
									useful if you write your own Activation Experience.
 */
struct ActivationExperienceResultParams
{
	1:	ActivationExpInterfaceVersionInfo	serverVersionInfo,		/** The version information of the experience library 
																		interface. */
	10: ActivationResult_T					result,					/** The basic result from the activation. */
	20: string								errorDescription = "",	/** Error description that will be set if result is 
																		ActivationResultError. */
}

//-----------------------
/**
 ActivateCallParams: This defines the calling parameters for the PACE Activation Experience when activating. 
 */
struct ActivateAuthCallParams
{	
	100:	string						experienceDataDirPath,				/** Top level directory for the experience config data - UTF-8 */
	110:	list<AuthChain>				warnAboutBestAuth,					/** If not empty, then the first entry in the vector will be 
																				used to warn the end user that the auth is going to expire 
																			    sometime in the future, or has already expired. */
	112:	optional ExpirationWarning	expirationWarningInfo,				/** Extra information about the auth to warn about, if there is one. */
	120:	optional i32				warnAutoDismissSeconds,				/** If set, then this is the number of seconds to wait before automatically
																	            dismissing a warning dialog about a future-expiring demo. */
	130:	bool						nagAndContinueOnExpiredDemo = 0,	/** If true, then the software is allowed to run on an expired demo 
																				auth, but only after nagging the user to activate. */
	132:	optional bool				noActivation,						/** If true and there is an auth to warn about, this means that we should warn
																				about the auth, but not allow them to activate. It covers the strange situation
																				that the wrap config says not to activate if the binary is not activated, but there
																				is a temporary auth available. */
	140:	bool						skipPublisherPage = 0,				/** If true, skip display of the publisher page and go directly
																				to the activation code entry page. */
	200:	WrapperPublicData			wrapperPublicData,					/** The WrapperPublicData struct extracted from the WrapConfig. This is used when
																				the PACE wrapper runs the experience. For calling activateAuth using the
																				PaceEden interface, callers use the paceEdenLicenseData data member below. 
																				One of them MUST be present.*/
	210:	list<AuthSituation>			authSituations,						/** These are problem situations that need to be communicated to  
																				the user.  These situations are returned by the findAuths and
																				verifyAuths functions. */
	300:	optional list<byte>			paceEdenLicenseData,				/** A flattened version of the exported license data. This contains 
																				a WrapperPublicData structure that has data needed for activation.
																				This data member should be used by PACE customer code that calls the
																				PaceEden interface activateAuth method. */
}

//-----------------------
/**
 DeactivateAuthCallParams:	This struct is the calling parameter set to use when starting the Activation Experience 
							for deactivation.
 */
struct DeactivateAuthCallParams
{	
	100:	string						experienceDataDirPath,			/** Top level directory for the experience config data */
	110:	list<WrapperAuthProduct>	productList,					/** The list of product auths that are candidates for deactivation. */
	120:	eLocationGroup validLocations = eLocationGroup.eLocal_LocationGroup,	/* Newest Thrift compiler won't let us use a constant here */
																		/** Can be used to limit the locations that will be searched for
																			auths to deactivate. Defaults to any location. */
}

//-----------------------
/**
 Define the different activation operation types that an ActivationAgent can be asked to perform.
 */
enum ActivationAgentOperationType
{
	kActivationAgentOperationActivate	= 0,
	kActivationAgentOperationDeactivate	= 1,
}

//-----------------------
/**
 ActivationAgentPreflightInvokeParams:	This struct is the calling parameter set that is used when a registered ActivationAgent is called
 to ask whether it can handle an activation for one or more products.
 */
struct ActivationAgentPreflightInvokeParams
{
	1: ActivationAgentOperationType opType,						/** Specifies the operation type. */
	2: list<WrapperAuthProduct>		productList,				/** The products of interest. */
}

//-----------------------
/**
 ActivationAgentIntention:	This enum tells us what the activation agent is prepared to do for the particular product(s) of interest.
 */
enum ActivationAgentIntention
{
	kAuthenticationOnly		= 0,	/** Will only authenticate */
	kActivationOperations	= 1,	/** Will activate or deactivate. */
}

//-----------------------
/**
 ActivationAgentPreflightInvokeResultParams:	This struct is the returned parameter set that is used when a registered ActivationAgent is called
 to ask whether it can handle an activation for one or more products. The Activation Agent is responsible for setting this result.
 
 If agentGraphics is true and a single agent is available, then the product Publisher's intro page will not be displayed. All product identification
 is the responsibility of the agent. If there are multiple agents available, then we must display a selection page. We want the end user to know what
 product we are trying to activate, so in this case we WILL display the product Publisher's intro screen (unless their wrapper settings suppressed it).
 
 If suppressTrial is true for ALL registered agents whose preflightInvoke() function is called, then the activation experience suppresses display
 of the "Try" button if the Publisher's Intro page is displayed.
 
 The intention of userAccountHidden is to tell the experience that that activation agent has a user currently logged in and the agent knows that
 the end user has an ilok.com account that was created on the users behalf by the agent. This information could be important if we were deciding
 whether to show ilok.com as one of the agent choices. Currently, we never provide ilok.com as a choice unless there is an error attempting to
 call an agent's invoke() callback or an agent returns an error. If your agent knows this information, please set it. We might start using it in 
 the future.
 
 The suppressAllLicensesExpired boolean tells the experience that it should not check for the situation where licenses are visible but all of 
 them are expired. Normally this results in a dialog being displayed. Set this true if you don't want the dialog displayed. This is a situation that 
 the agent can detect on it's own through the Eden API. Note that this boolean is only effective if ALL registered agents whose preflightInvoke() 
 function is called agree on it.
 
 The suppressPreviousIlokCheck boolean tells the experience that it should not check for the case where an iLok license was used to authorize the 
 binary the last time it ran, but no license is visible now. That situation normally displays a dialog that says "Do you have this iLok?" and explains
 what it is looking for. Set true if you don't want this dialog to ever display. The Eden API does not currently offer a way to get this information,
 so agents will not be able to handle it on their own. Note that this boolean is only effective if ALL registered agents whose preflightInvoke()
 function is called agree on it.
 */
struct ActivationAgentPreflightInvokeResultParams
{
	1: bool		willHandle,								/** If true, then the agent will handle the authentication or activation for the products. */
	2: optional ActivationAgentIntention intention,		/** Tells what the agent can do when willHandle is true. */
	3: optional bool agentGraphics,						/** Set true if the agent wants to handle all graphics. */
	4: optional bool suppressTrial,						/** Set true if built in trials should be suppressed for the product(s). */
	5: optional bool userAccountHidden,					/** Set true if the the current user has a "hidden" ilok.com account. */
	6: optional bool suppressAllLicensesExpired,		/** Set true tells experience not to check and display the "all visible licenses are expired" dialog. */
	7: optional bool suppressPreviousIlokCheck,			/** Set true tells experience to never display the "Do you have this iLok?" dialog. */
}

//-----------------------
/**
 ActivationAgentActivationParameters:	This struct is the calling parameter set that is used when a registered ActivationAgent is called
 for activation or deactivation.
 */
struct ActivationAgentInvokeParams
{
	1: ActivationAgentOperationType			opType,					/** Specifies the operation type. */
	2: optional ActivateAuthCallParams		activateParams,			/** If calling for activation, these are the parameters. */
	3: optional DeactivateAuthCallParams	deactivateParams,		/** If calling for deactivation, these are the parameters. */
}

//-----------------------
/**
 ActivationAgentResult:	Possible result codes for Activation Agent activation/deactivation.
 */
enum ActivationAgentInvokeResultValue
{
	kActivationAgentInvokeResultOk			= 0,		/** The agent ran successfully */
	kActivationAgentInvokeResultError		= 1,		/** The agent encountered an error */
	kActivationAgentInvokeDidNotHandle		= 2,		/** The agent was not able to do anything but another agent might be able to handle the activation. */
	kActivationAgentInvokeNoProcess			= 3,		/** The agent process was not running when we tried to invoke it. */
	kActivationAgentInvokeAgentUnavailable	= 4,		/** The agent process is unregistering or has unregistered */
}

//-----------------------
/**
 ActivationAgentInvokeResultParams:	This struct is the returned parameter set that is used when a registered ActivationAgent is called
 for activation or deactivation.
 */
struct ActivationAgentInvokeResultParams
{
	 1: ActivationAgentInvokeResultValue			result = ActivationAgentInvokeResultValue.kActivationAgentInvokeResultOk,	/** The basic result of the agent invocation */
	 2: optional string								errorDescription = "",	/** If set, this is a string the agent wants us to display as the result of the activate/deactivate. */
	 
	11: optional string								accountId,				/** If the agent only authenticates, this is the ilok.com account login ID */
	12: optional string								authenticationToken,	/** If the agent only authenticates, then this is the token it got from EdenRemote */
	
}

//-----------------------
/**
 Thrift data ID of persistent form of auth status information. The value is actually 'asts' in little endian.
 WARNING! Since this value is persisted into flattened authorization status structures, it needs to be kept
 sync between the wrapper and any Eden API calls that would access it. 
 <p>
 The simple thing to do would be to never change this value.
 */
const i32 kWrapperStatusThriftDataId			= 0x78687461,


/**
 If this environment variable is set to "1", then subsequent executions of Eden wrapped software will
 record their last auth status in the environment variable named kWrapperLastAuthStatusEnvVarName.
 */
const string kWrapperRecordStatusEnvVarName	= "PACE_EDEN_WRAPPER_RECORD_STATUS"

/**
 The environment variable name that contains the encoded wrapper status of the last loaded wrapped binary.
 */
const string kWrapperLastStatusEnvVarName	= "PACE_EDEN_WRAPPER_LAST_STATUS"


/**
 Adapter parameters version numbers.
 */
enum WrapperStatusVersion
{
	kWsVersion1 = 1,		/** The current version is 1. */
	kWsVersion2,			/** This version is reserved for future use. */
}

/**
 Structure that encapsulates wrapper status. This structure is flattened to a PACE
 proprietary binary format, then encoded as a base 64 string that in turn will be 
 associated with an environment variable. A host application can obtain the env var, 
 decode the string, and learn about the status of a loaded wrapped shared library.
 */
struct WrapperStatus
{
	1:	WrapperStatusVersion version = WrapperStatusVersion.kWsVersion1,			/** Version of this object. */
	2:	WrapperStatusVersion minimumVersion = WrapperStatusVersion.kWsVersion1,		/** Code that reads this structure must be at least this version  
																						number or above to understand this structure. */
	
	11: string executionDate,									/** Date/time in ISO 8601 format (with microseconds, on supported
																 platforms) that the wrapper ran. */
	
	21:	Identity wrapConfig,									/** Wrap configuration ID. */
	22:	Identity publisher,										/** Publisher name and ID. */
	23:	Identity product,										/** Product name and ID. */
	
	31:	bool isAuthorized = 0,									/** If true, then the wrapped executable was authorized to run. */
}

// --------------- ActivationServices API Definitions
/**
These define various server errors that can be encountered in a CommonResult.
*/
const string kFatalClientServerConnectionError		= "ServerConnectionError"		/** Couldn't open a connection with activation server. */
const string kFatalClientServerRetryError			= "ServerRetryError"			/** The server gave us an error back after retrying to recover from a network error. */
const string kFatalClientNetworkError				= "NetworkError"				/** A network error happened while talking with the activation server. */
const string kFatalClientInvalidSessionId			= "InvalidSessionId"			/** The session ID provided was invalid. */
const string kFatalClientIlokNotFound				= "IlokNotFound"				/** The specified iLok is not attached to the client machine. */
const string kFatalClientIlokDestinationError		= "IlokDestinationError"		/** An error happened configuring the destination iLok for activation or deactivation. */
const string kFatalClientServiceIsStopping			= "ServiceIsStopping"			/** The frontend service is stopping. */
const string kFatalClientUnexpectedException		= "UnexpectedException"			/** Some internal PACE error happened. */
const string kFatalClientVersionOutdated			= "ClientVersionOutdated"		/** The licenseDaemonVersion or frontendClientVersion is too old to work with the server. */
const string kFatalClientServiceUnavailable         = "ClientUnavailable"           /** licenseDaemon is unavailable */

const string kFatalServerServiceUnavailable			= "ServiceUnavailable"			/** The activation service is unavailable. Check the service ETA for when service will be restored. */
const string kFatalServerUnexpectedException		= "ServerUnexpectedException"	/** The server encountered an internal error */
const string kFatalServerInvalidSessionId			= "InvalidSessionId"			/** The session ID provided was invalid. */
const string kFatalServerInvalidOperationId			= "InvalidOperationId"			/** An invalid operation ID was provided. */
const string kFatalServerInvalidClientWorkId		= "InvalidClientWorkId"			/** An invalid client work ID was provided. */
const string kFatalServerInvalidDatabaseInfo		= "InvalidDatabaseInfo"			/** An invalid database info object was provided. */
const string kFatalServerInvalidMachineId			= "InvalidMachineId"			/** An invalid machine ID object was provided. */
const string kFatalServerInvalidLicenseSummary		= "InvalidLicenseSummary"		/** An invalid license summary object was provided. */
const string kFatalServerInvalidAccountId			= "InvalidAccountId"			/** A non-empty, invalid account ID was provided (authenticateSession) */
const string kFatalServerInvalidPassword			= "InvalidPassword"				/** The password for the account ID was invalid, used during createAccount and authenticateSession */
const string kFatalServerInvalidEmail				= "InvalidEmail"				/** The email provided (createAccount) was null or did not match regex check */
const string kFatalServerDuplicateAccountId			= "AccountIdInUse"				/** The desired accountId is already in use */
const string kFatalServerDuplicateAccount			= "DuplicateAccount"			/** The account details provided match an existing account */
const string kFatalServerInvalidDatabaseInfoUuid	= "InvalidDatabaseInfoUuid"		/** The database info uuid provided was invalid. */
const string kFatalServerAuthenticationRequired		= "AuthenticationRequired"		/** This operation requires an authenticated session */
const string kFatalServerActivationCodeNotFound		= "ActivationCodeNotFound"		/** The code provided was not found in the DB */
const string kFatalServerBadActivationCode			= "ActivationCodeInvalid"		/** The code provided did not decrypt properly */
const string kFatalServerActivationCodeExpired		= "ActivationCodeExpired"		/** The code provided has expired */
const string kFatalServerRedeemedTransferred		= "RedeemedTransferred"			/** The code provided has been redeemed and the resulting DRight transferred to another user */
const string kFatalServerRedeemptionsExhausted		= "RedeemptionsExhausted"		/** The code provided has no remaining redemptions available */
const string kFatalServerRedeemBadUser				= "RedeemBadUser"				/** Invalid user presented during redemption - Should never happen */
const string kFatalServerWrongCodeVersion			= "WrongCodeVersion"			/** A cryptographically valid code with the wrong version was provided (Beta on Production, eg) */
const string kFatalServerTooManyAttempts			= "TooManyAttempts"				/** Attempt to redeem a code too many times */
const string kFatalServerDrightNotFound				= "DrightNotFound"				/** DRight GUID provided during activation could not be found */
const string kFatalServerDrightNotOwned				= "DrightNotOwned"				/** DRight GUID provided during activation is not owned by current user */
const string kFatalServerDrightNotUsable			= "DrightNotUsable"				/** DRight status indicates not "usable" */
const string kFatalServerNoRemainingActivations		= "NoRemainingActivations"		/** DRight has no activations remaining */
const string kFatalServerLocationNotAllowed			= "LocationNotAllowed"			/** DRight cannot be activated at chosen location */
const string kFatalServerTrialActivatedAccount		= "TrialActivatedInAccount"		/** DRight is for a Trial of some sort that has already been activated by current user. */
const string kFatalServerTrialActivatedLocation		= "TrialActivatedOnLocation"	/** Dright is for a Trial of some sort that has already been activated to this location. */
const string kFatalServerActivationGUIDNotFound		= "ActivationNotFound"			/** ActivationGUID provided during preflight/deactivate could not be found */
const string kFatalServerTransferNotAllowedActive	= "TransferNotAllowedActive"	/** The DRight cannot be transferred, still activated somewhere */
const string kFatalServerTransferForbidden			= "TransferForbidden"			/** The DRight cannot be transferred; Publisher forbids transfer */
const string kFatalServerTransferNotAllowed			= "TransferNotAllowed"			/** The Dright cannot be transferred for reason other than publisher not allowing it */
const string kFatalServerMissingParameter			= "RequiredParameterMissing"	/** A parameter was either null or empty */
const string kFatalServerIlokNotOwned				= "IlokNotOwned"				/** The user does not own the specified iLok */
const string kFatalServerIlokNotRegistered			= "IlokNotRegistered"			/** The iLok is known to the server, but not registered to any user */
const string kFatalServerIlokFull					= "IlokFull"					/** The iLok does not have enough space to hold the dright(s) being activated */
const string kFatalServerIlokNotEmpty				= "IlokNotEmpty"				/** Attempt to unregister an iLok with active licenses */
const string kFatalServerInsufficientUserPrivileges	= "InsufficientUserPrivileges"	/** The user does not have sufficient privileges for the requested operation. This could happen if a regular user tries to make developer-only calls, for example. */
const string kFatalServerUnknownPlatform			= "UnknownPlatform"				/** An unknown platform was provided */
const string kFatalServerPublisherNotFound			= "PublisherNotFound"			/** No publisher with the provided guid could be found */
const string kFatalServerBadAuthId					= "AuthIdNotFound"				/** AuthId passed to getProductConfig was not found */
const string kFatalServerNoAnonymousUser			= "NoAnonymousUser"				/** The server DB is misconfigured and no anonymous account is defined */
const string kFatalServerRedemptionNotFound			= "NoRedemptionFound"			/** While processing a takePossession operation no redemption was found for the code */
const string kFatalServerCodeNeverRedeemed			= "CodeNeverRedeemed"			/** While processing a takePossession operation the code provided has never been redeemed */
const string kFatalServerNoAnonymousMachineAccount	= "NoAnonymousMachineAccount"	/** While processing a takePossession operation no machine account was for the anonymous user */
const string kFatalServerAccountFraudLocked			= "AccountFraudLocked"			/** User's account is Fraud Locked */
const string kFatalServerAccountDisabled			= "AccountDisabled"				/** User's account is disabled */
const string kFatalServerAccountNotConfirmed		= "AccountNotConfirmed"			/** User has not confirmed their account */
const string kFatalServerDrightExpired				= "DrightExpired"				/** Dright has expired */
const string kFatalServerDeliveryNotOwned			= "DeliveryNotOwned"			/** Delivery not owned by the user */
const string kFatalServerLocationNotAvailable		= "LocationNotAvailable"		/** Location selected is not available */
const string kFatalServerLicensesToSurrenderNotFound = "LicensesToSurrenderNotFound" /** The surrender cannot be satisfied because the licenses to surrender are not found in the user's account */
const string kFatalServerNoRemainingCyleCounts		= "NoRemainingCycleCount"		/** There are no more cycle counts available */
const string kFatalServerNotSubscribedToZdt			= "NotSubscribedToZdt"			/** No Zdt membership either because its expired, never activated, cancelled, not renewed etc */
const string kFatalServerLocationDoesNotSupportLos	= "LocationDoesNotSupportLos"	/** Los is not supported for this location type */
const string kFatalServerIlokHasSigningCredentials	= "IlokHasSigningCredentials"	/** The iLok has signing credentials */
const string kFatalServerLocationInsufficientSpace	= "InsufficientSpaceOnLocation"	/** The location does not have enough space for the auths being activated */
const string kFatalServerMissingLicenseForSurrender = "LicenseRequiredForSurrenderMissing" /** A surrender required more licenses than were provided */
const string kFatalServerObjectNotFound				= "ObjectNotFound"				/** Generic object not found error. Useful for calls from third parties who might get the data wrong or use stale data. */
const string kFatalServerArchiveNotAllowedActive	= "ArchiveNotAllowedActive"		/** Cannot archive license since it is active on one or more locations */
const string kFatalServerIlokFirmware				= "IlokFirmwareProblem"			/** Possible iLok firmware error detected */
const string kFatalServerIlokUSB					= "IlokUSBProblem"				/** Possible iLok USB problem detected */
const string kFatalServerDeliveryNotUsable			= "DeliveryNotUsable"			/** Delivery not usable because it was revoked, cancelled etc */
const string kFatalServerTokenExpired				= "TokenExpired"				/** Session token has expired */

const string kFatalServerWrapConfigNotFound				= "WrapConfigNotFound"				/** Couldn't find the wrap config for the specified GUID. */
const string kFatalServerWrapConfigWrongOwnership		= "WrapConfigWrongOwnership"		/** The wrap config specified exists, but is owned by different publisher than those available to the specified user. */
const string kFatalServerWrapConfigWrongPermissions		= "WrapConfigWrongPermissions"		/** The wrap config specified exists, but the specified user does not have permissions to access it. */
const string kFatalServerWrapConfigBinariesUnavailable	= "WrapConfigBinariesUnavailable"	/** The wrapper binaries associated with the wrap config are not available for use. */

const string kFatalServerUserCannotAccessService	= "UserCannotAccessService"		/** The user is not allowed to access the requested service. */
const string kFatalServerUnknownServiceId			= "UnknownServiceId"			/** The service ID specified in the getAccessCredentials call is not known. */

/** These are only returned by LicenseD when there are errors registering or unregistering Activation Agents. */
const string kErrorActivationAgentBadPid					= "ActivationAgentProcessIdInvalid"				/** The provided PID is invalid */
const string kErrorActivationAgentThriftServerNoResponse	= "ActivationAgentThriftServerNotResponding"	/** Could not talk to the Trift server on specified local port. */
const string kErrorActivationAgentInUse						= "ActivationAgentIsInUse"						/** Could not unregister or replace the agent because it is being called. */
const string kErrorActivationAgentWrongProcess				= "ActivationAgentWrongProcess"					/** Attempt to unregister from the wrong process. */

/** Operation status values - these are not errors. */
const string kOperationStatusTransferRequiresApproval = "TransferRequiresApproval"	/** The DRight can be transferred, but must be approved by the publisher */
const string kOperationStatusCannotReactivate		= "CannotReactivate"			/** Warning during deactivation that the cycle limit has been reached */
const string kOperationStatusAlreadyActive			= "AlreadyActive"				/** The DRight is already active at the specified location */
const string kOperationStatusRedeemedNotActivated	= "RedeemedNotActivated"		/** Code has been redeemed but not activated */
const string kOperationStatusRedeemedAndActivated	= "RedeemedAndActivated"		/** Code has been redeemed *and* activated */
const string kOperationStatusNotActive				= "NotActive"					/** The specified activation is already inactive (preflight/deactivate) */
const string kOperationStatusLosAlreadyActive		= "LosAlreadyActive"			/** Location is already nominated for Los */
const string kOperationStatusLosAlreadyDeactived	= "LosAlreadyDeactived"			/** Loction has been denominated from Los */
const string kOperationStatusDbDriftRepaired		= "DbInitializedDueToDrift"		/** Database machine bindings were not within drift tolerance. 
																					 Database has been initialized as new. This can be returned by openSession.
																					 The session will be opened as long as there was no error. The user should
																					 be told that this happened because any machine activations will have
																					 been lost.*/

/**
 AuthorizationStatus string constants as passed from server to client.  Do not change existing strings!
 */
const string kAuthorizationStatus_Pending			= "pending";
const string kAuthorizationStatus_Deposited			= "deposited";
const string kAuthorizationStatus_Activated			= "activated";
const string kAuthorizationStatus_SurrenderedFully	= "surrendered";
const string kAuthorizationStatus_Revoked			= "revoked";
const string kAuthorizationStatus_Deleted			= "deleted";
const string kAuthorizationStatus_HiddenByUser		= "hidden";
const string kAuthorizationStatus_SurrenderPending	= "surrender_pending";
const string kAuthorizationStatus_ApprovalPending	= "approval_pending";
const string kAuthorizationStatus_PaymentPending	= "payment_pending";
const string kAuthorizationStatus_ResalePending		= "resale_pending";
const string kAuthorizationStatus_Resold			= "resold";
const string kAuthorizationStatus_MigrationLimbo	= "migration_limbo";
const string kAuthorizationStatus_Expired			= "expired";
const string kAuthorizationStatus_NotYetValid		= "not_yet_valid";
const string kAuthorizationStatus_RevokePending		= "revoke_pending";
// For subscription auths:
const string kAuthorizationStatus_Suspended			= "suspended";				/** Publisher has suspended, but current date is before Auth stop date */
const string kAuthorizationStatus_SuspendedExpired	= "suspended_expired";		/** Publisher has suspended, and current date is >= Auth stop date */
const string kAuthorizationStatus_Terminated		= "terminated";				/** Publisher has terminated, but current date is before Auth stop date */
const string kAuthorizationStatus_TerminatedExpired	= "terminated_expired";		/** Publisher has terminated, and current date is >= Auth stop date */

/**
 AuthorizationStatusFilter constants passed to getLibrary and getLibraryWithFilters.
 */
enum AuthorizationStatusFilter
{
    kAuthorizationStatus_Pending_Filter =           0x0000000000000001,
    kAuthorizationStatus_Deposited_Filter =         0x0000000000000002,
    kAuthorizationStatus_Activated_Filter =         0x0000000000000004,
    kAuthorizationStatus_Surrendered_Filter =       0x0000000000000008,
    kAuthorizationStatus_Revoked_Filter =           0x0000000000000010,
    kAuthorizationStatus_Deleted_Filter =           0x0000000000000020,
    kAuthorizationStatus_Hidden_Filter =            0x0000000000000040,
    kAuthorizationStatus_SurrenderPending_Filter =  0x0000000000000080,
    kAuthorizationStatus_ApprovalPending_Filter =   0x0000000000000100,
    kAuthorizationStatus_PaymentPending_Filter =    0x0000000000000200,
    kAuthorizationStatus_ResalePending_Filter =     0x0000000000000400,
    kAuthorizationStatus_Resold_Filter =            0x0000000000000800,
    kAuthorizationStatus_MigrationLimbo_Filter =    0x0000000000001000,
    kAuthorizationStatus_Expired_Filter =           0x0000000000002000,
    kAuthorizationStatus_NotYetValid_Filter =       0x0000000000004000,
    kAuthorizationStatus_RevokePending_Filter =		0x0000000000008000,
	kAuthorizationStatus_Suspended_Filter =			0x0000000000010000,
    kAuthorizationStatus_SuspendedExpired_Filter =  0x0000000000020000,
    kAuthorizationStatus_Terminated_Filter =		0x0000000000040000,
    kAuthorizationStatus_TerminatedExpired_Filter =	0x0000000000080000,
	
	
    // kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter
    kAuthorizationStatus_Active_Filter = 0x0000000000000086,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Suspended_Filter |
	// kAuthorizationStatus_Terminated_Filter
    kAuthorizationStatus_Active_Filter_V2 = 0x0000000000050086,
		
    // kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
    kAuthorizationStatus_ActiveExpired_Filter = 0x0000000000002086,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
	// kAuthorizationStatus_Suspended_Filter | kAuthorizationStatus_Terminated_Filter | kAuthorizationStatus_SuspendedExpired_Filter | kAuthorizationStatus_TerminatedExpired_Filter
    kAuthorizationStatus_ActiveExpired_Filter_V2 = 0x00000000000F2086,
	
    // kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter |
    // kAuthorizationStatus_Expired_Filter | kAuthorizationStatus_Surrendered_Filter
    kAuthorizationStatus_ActiveExpiredSurrender_Filter = 0x000000000000208E,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter |
    // kAuthorizationStatus_Expired_Filter | kAuthorizationStatus_Surrendered_Filter | kAuthorizationStatus_Suspended_Filter | kAuthorizationStatus_Terminated_Filter |
	// kAuthorizationStatus_SuspendedExpired_Filter | kAuthorizationStatus_TerminatedExpired_Filter
    kAuthorizationStatus_ActiveExpiredSurrender_Filter_V2 = 0x00000000000F208E,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
    // kAuthorizationStatus_Surrendered_Filter | kAuthorizationStatus_Resold_Filter | kAuthorizationStatus_ApprovalPending_Filter | kAuthorizationStatus_PaymentPending_Filter |
	// kAuthorizationStatus_ResalePending_Filter
    kAuthorizationStatus_Visible_Filter = 0x0000000000002F8E,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
    // kAuthorizationStatus_Surrendered_Filter | kAuthorizationStatus_Resold_Filter | kAuthorizationStatus_ApprovalPending_Filter | kAuthorizationStatus_PaymentPending_Filter |
	// kAuthorizationStatus_ResalePending_Filter | kAuthorizationStatus_Suspended_Filter | kAuthorizationStatus_Terminated_Filter | kAuthorizationStatus_SuspendedExpired_Filter |
	// kAuthorizationStatus_TerminatedExpired_Filter
    kAuthorizationStatus_Visible_Filter_V2 = 0x00000000000F2F8E,
	
    // kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
    // kAuthorizationStatus_Surrendered_Filter | kAuthorizationStatus_Resold_Filter | kAuthorizationStatus_ApprovalPending_Filter | kAuthorizationStatus_PaymentPending_Filter |
	// kAuthorizationStatus_ResalePending_Filter | kAuthorizationStatus_RevokePending_Filter
    kAuthorizationStatus_VisibleWithRevokePending_Filter = 0x000000000000AF8E,
	
	// kAuthorizationStatus_Deposited_Filter | kAuthorizationStatus_Activated_Filter | kAuthorizationStatus_SurrenderPending_Filter | kAuthorizationStatus_Expired_Filter |
    // kAuthorizationStatus_Surrendered_Filter | kAuthorizationStatus_Resold_Filter | kAuthorizationStatus_ApprovalPending_Filter | kAuthorizationStatus_PaymentPending_Filter |
	// kAuthorizationStatus_ResalePending_Filter | kAuthorizationStatus_RevokePending_Filter | kAuthorizationStatus_Suspended_Filter | kAuthorizationStatus_Terminated_Filter |
	// kAuthorizationStatus_SuspendedExpired_Filter | kAuthorizationStatus_TerminatedExpired_Filter
    kAuthorizationStatus_VisibleWithRevokePending_Filter_V2 = 0x00000000000FAF8E,
	
}

/**
 These define various keys for notifications that can be set in a CommonResult.
 */
const i32 kNotificationKey_extraIlokWorkTellUser			= 1;
const i32 kNotificationKey_userNotificationAvailable		= 2;

/**
 These are the string constants that can be used as values in CommonResult.notifications
 */
const string kNotification_doNotUnplugIloks			= "NotificationDoNotUnplugIloks"					/** Client should inform user not to unplug their iLoks. */
const string kNotification_expiredLicensesToAccount = "NotificationExpiredLicensesDeactivatedToAccount"	/** Expired licenses are being deactivated back to account */

/**
 This structure is returned if an error happened for a given operation.
 */
struct ErrorResult
{
	1:	string errorCode = "",				/** The error code that happened. The caller should localize it if possible for display to the user. */
	2:	string errorMessage = "",			/** If non-empty, this is an error message from the server. The caller should localize it if possible for display to the user. */
	3:	optional string serviceEta,			/** If set and non-empty, then this is the estimated GMT date/time when services will be available. Specified in the same ISO 8601 extended format that we use for times in the client database (i.e. YYYY-MM-DDTHH:MM:SS.nnnnnnZ). */
	4:	optional string errorExtraData,		/** Optional error-specific data. Originally added so that the "kFatalClientVersionOutdated" error could also return a download URL. */
}

/**
 These constants indicate the percentage complete for a given operation.
 */
enum PercentComplete
{
	IndeterminatePercent	= -1,		/** It's not possible to know the percentage complete because the current status is indeterminate. */
	ZeroPercent				= 0,		/** Zero percent complete. */
	OneHundredPercent		= 100,		/** We're 100% complete. */
}

/**
 This structure is returned from all activation frontend and backend calls.
 Note that any frontend or backend call will return in a reasonable amount of
 time, although it might not be complete. Operations that complete quickly
 will return that the operation is done immediately.
 <p>
 Operations that will take some time will indicate that fact in the common
 return data below. It's up to the client to follow up as needed with the
 server to determine the status of an outstanding operation.
 */
struct CommonResult
{
	1:	optional ErrorResult error,						/** If set, an error happened. Drill into the struct to find out why. */
	2:	string operationId,								/** This server issued string identifies the operation if needed for future calls. */
	3:	i32 percentComplete = PercentComplete.OneHundredPercent,	/** When set to 100, the operation is complete. If indeterminate, the value will be -1. Otherwise the value is the initial percentage done. */
	4:	optional string statusCode,						/** This status code (which should be localized by the client), indicates the status of the operation. */
	5:	optional string statusMessage,					/** This status message (which should be localized by the client), indicates the detailed status of the operation. */
	6:	optional map<i32, list<string> > notifications,	/** Optional notifications that server can set. The keys are defined as kNotificationKey_* above and have type i32. The values may be an empty list,
															one of the strings defined as kNotification_* above or a server defined one. */
}

/**
 This is the data type that returns server notifications.
 */
typedef map<i32, list<string> > ServerNotificationsMap_T
typedef list<string>			ServerNotificationsList_T



/**
 Indicates the version of the wrapper binary to use for wrapping.
 */
struct VersionedIdentity
{
	1:	optional string name,		/** Name portion of the identity */
	2:	string guid,				/** The PACE issued GUID of a wrap config, wrapper binaries, experience, etc. */
	3:	i32 revision = 0,			/** Revision number associated with the wrapper data. This should be an incrementing integer. */
	4:	optional string version,	/** Version string for display purposes. This should be human readable, like "1.0b1", for example. */
}

/**
 Structure that defines versioned data. The structure may actually contain
 the data itself, or it may have a URL where the data can be found.
 */
struct VersionedData
{
	1:	VersionedIdentity id,		/** Identiy information, icluding revision number and version string. */
	2:	string dataType,			/** Type of data, i.e. flattened thrift data, zip archive, etc. */
	3:	optional list<byte> data,	/** If set, the server is providing the data directly. This will probably flattened thrift data, but depends on the dataType indicated. */
	4:	optional string url,		/** If set, this is the URL from which the actual data can be downloaded. */
}

/**
 Structure used to provide version information for software, including the milestone and revision.
 */
struct SoftwareVersion
{
	/** Version number string. */
	1:	string versionNumber;
	
	/** The milestone of the software, like B7 or GM. */
	2:	string milestone;
	
	/** The source control revision number string. */
	3:	string revision;

	/** Build number string. For PACE built software this will correspond with the Jenkins build number. */
	4:	string buildNumber;	
}

/**
 Define a type for the iLok1 an iLok2 serial number.
 */
typedef i64 IlokSerialNumber_T

/**
 These are iLok model identifiers used in the activation API only.  These are provided, so that clients can display
 icons matching the iLokType.  Making activation decisions based on the iLokType is NOT recommended in client code.
 Such decisions should happen automatically by your product settings on the Eden Server and by license data provided to
 the activation API.
 */
enum IlokType
{
	iLok1 = 1,
	iLok2,
	iLok3,
	iLok4,
}

/**
 Enum to identify status of an iLok. Clients like ILM use this to present different badges on the iLok icon
 */
enum IlokStatus 
{
	kNormal = 1,			/** Normal state */
	kRma,					/** RMA - broken or non-functional */
	kForgottenPassword,		/** RMA - forgot password */
	kRmaLost,				/** RMA - lost */
	kRmaStolen,				/** RMA - stolen */
	kHasSigningCredentials, /** Has digital signing certificate */
	kRetryExceeded,			/** Sync retry exceeded */
}

/**
 Structure to completely identify an iLok, includes type and serial number.
 type is defaulted to iLok1 to facilitate use in registerILok, where the server will ignore it.
 */
struct IlokIdentifier
{
	1:	IlokType type = IlokType.iLok1,
	2:	IlokSerialNumber_T serialNumber,
}


/**
 Structure to hold Zdt and possibly Los info
 */
struct ZdtAndLosInfo
{
	1:	optional string zdtStartDate,		/** Zdt start date */
	2:	optional string zdtEndDate,			/** Zdt end date */
	3:	optional string losStartDate,		/** Los start date */
	4:	optional string losEndDate,			/** Los end date */
	5:	bool supportZdtWithoutLos = 0;		/** If true, then a location is capable of supporting
											 ZDT without LOS and PACE offers ZDT without LOS for this
											 location. */
	6:	bool supportLos = 0;				/** If true, then a location is capable of supporting
											 LOS which always includes ZDT and PACE offers LOS for 
											 this location. */
}


/**
 This is used to set/return iLokInfo, includes iLokIdentifier and alias set by the user.
 Parameters are defaulted to empty strings to facilitate use in registerIlok.
 */
struct IlokInfo
{
	1:	IlokIdentifier ilokIdentifier,
	2:	string ilokAlias = "",				/** Short name for the iLok */
	3:	string ilokDescription = "",		/** Long user assigned description */
	4:	IlokStatus ilokStatus = IlokStatus.kNormal,		/** Status for the iLok */
	5:	optional string accountId,			/** AccountId of owner of this iLok */
	6:	optional ZdtAndLosInfo zdtAndLosInfo,	/** Any Zdt/Los info for the ilok */
	7:	optional string signingCertificateExpirationDate,	/** Expiration date of the digital signing certificate if the iLok has one */
}

/**
 Define a list of IlokInfo records.
 */
typedef list<IlokInfo> IlokInfoList_T


/**
 Similar structure, used for identifying existing activations.  Includes iLok type to make things easier.
 Used in preflightActivate, so we include optional Status information.
 <p><p>
 Note that this structure is also used to return information about locations that belong to the logged in user
 (in the case of iLoks) or that the logged in user has activations on (in the case of machines). These locations
 are known for historical (MyLicenses-related) reasons as "offline locations", or "registered locations".
 */
struct ActivationLocation
{
	/** Host activation */
	1:	bool hostMachine = 1;
	
	/** Name of the machine */
	2:	optional string machineName;
	
	/** Type and Serial Number */
	3:	optional IlokInfo ilokInfo;
	
	/** Optional status */
	4:	optional string statusCode;
	
	/** Detailed message */
	5:	optional string statusMessage;
	
	/** Count of auths active on this location */
	6:	optional i32 authCount;
	
	/** Any Zdt and/or Los details for machine. Zdt/Los info for the ilok is in the Ilok.IlokInfo structure. */
	7:	optional ZdtAndLosInfo machineZdtLosInfo;
	
	/** The machine identifier GUID, because machines can have multiple names. Added at the end for compatibility reasons. */
	8:	optional string machineGuid;
}

/**
 Define a list of ActivationLocation structures.
 */
typedef list<ActivationLocation> ActivationLocationList


/**
 Structure used to define where to activate
 */
struct ActivationDestination
{
	/** Host Activation */
	1:	bool hostMachine = 1;

	/** If set then the target is an iLok */
	2:	optional IlokSerialNumber_T ilokSerialNumber;
}


/**
 Structure for disallowed activation destinations, includes ActivationLocation and
 ErrorResult (to provide short/long error code/message) explaining why the location is not allowed
 */
struct DisallowedDestination
{
	1:	ActivationLocation	destination;
	2:	ErrorResult errorResult;
}


/**
 Structure detailing an existing activation for this user.
 */
struct Activation
{
	/** Unique identifier of this activation */
	1:	string activationGuid;
	
	2:	ActivationLocation activationLocation;
	
	/** Set to true if this activation is queued */
	3:	bool queued = 0;
	
	/** Set if this activation has an expiration date. Used for subscription based licenses. */
	4:	optional string expirationDate;
	
	/** Number of seats allocated for this activation. Will be set if this is an activation of a shared license. */
	5:	i32 allocatedSeats;	
	
	/** iLok storage location if this is an iLok activation */
	6:	optional string iLokStorageLocation;
	
	/** Grace Period in days. Used for subscription based licenses. */
	7: optional i32 subscriptionGracePeriodDays;

}

/**
 Structure that carries Release Date limits. These are only available to PACE authorized Publishers.
 */
struct DrightReleaseDateLimits
{
	/** The "Not Valid Before" date for the Dright. No limit if not present. */
	1: optional string notValidBefore;
	
	/** Thehe "Not Valid After" date for the Dright. No limit if not present. */
	2: optional string notValidAfter;
}

/**
 Structure that defines the possible types of release limits that may be applied to a Dright. We made
 a single structure that groups the possible limit types so that checking for limits is easier.
 <p>
 The single data member is optional because we are allowing for another limit type in the future.
 <p>
 Release limits are only available to PACE authorized Publishers.
 */
struct DrightReleaseLimits
{
	/** If present, this Dright has Date limits. */
	1: optional DrightReleaseDateLimits dateLimits;
	
	/** Reserved for future limit types. */
}

/** Lookup table of localized (someday) strings for DrightInfos. The intent is: map<GUID, map<locale, string> >. We currently only support EN-US. */
typedef map<string, map<string, string> > LocalizedStringMap

/**
 Structure used to identify a DRight ("digital right").  This provides the base info for the DRight.
 */
struct DrightInfo
{
	/** The identifier used by the Eden Activation API (activateStart) to activate the Authorization represented by this DrightInfo.
		Note that the EdenRemote queries use "productGuid" (see below).
	 */
	1:	string drightId;
	
	/** If this is a child DRight */
	2:	optional string parentId;
	
	/** aka publisher */
	3:	i32 participantId;
	
	/** For Experience, which cannot lookup ids */
	4:	optional string participant;
	
	/** aka productId */
	5:	i32 authId;
	
	/** For Experience, which cannot lookup ids */
	6:	optional string authName;
	
	/** Product, Bundle, Set, Feature, etc. */
	7:	string role;
	
	/** Plugin, Application, Content, etc. */
	8:	string category;
	
	/** Pro-Audio, Games, etc. */
	9:	string marketSegment;
	
	/** Full, Trial, Demo, etc */
	10:	string licenseType;
	
	/** DRight status (Deposited, Activated, Revoked, etc */
	11:	string status;
	
	/** Can right be moved between iLoks */
	12:	bool iLokMove;
	
	/** Can right be transfered to another account (resold) */
	13:	bool transfer;
	
	/** Max allowed activations */
	14:	i32 allowedActiveCount;
	
	/** Number of active activations across all locations */
	15:	i32 currentActiveCount;
	
	/** Date this right was deposited to user's account */
	16:	optional string depositDate;
	
	/** If this DRight expires */
	17:	optional string expirationDate;
	
	/** If this DRight has a defined period. This is specified in seconds. */
	18:	optional i32 licensePeriod;
	
	/** If this DRIght has a launch count */
	19:	optional i32 launchCount;
	
	/** Where this DRight may be activated */
	20:	eLocationGroup validLocations = eLocationGroup.eLocal_LocationGroup;
	
	/** Activations if such exist */
	21:	optional list<Activation> activations;
	
	/** If license is not activated before this date, the user can no longer use it. */
	22: optional string activateByDate;
	
	/** This is the license period as set in PC2. # units. This can be used by clients like MyLicenses to show the license period to the user */
	23: optional string displayLicensePeriod;
	
	/** List of legacy tokens that are enabled */
	24:	optional list<string> legacyTokenNames;
	
	/** Dright Icon */
	25: optional VersionedData icon;
	
	/** Dright Box art */
	26: optional VersionedData boxArt;
	
	/** Activation code (internally called a "Pukka" code at PACE) associated with this Dright */
	27: optional string pukkaCode;
	
	/** Product Url that can be set via PC2 */
	28: optional VersionedData productUrl;
	
	/** Publisher Url that can be set via PC2 */
	29: optional VersionedData publisherUrl;
	
	/** Does transfer of this right to another account require publisher approval? */
	30: bool transferNeedsApproval;
	
	/** This dright is unavailable for activation. Added for Trial location enforcement. */
	31: optional bool inhibitActivation;
	
	/** Set to true if this dright has a surrender requirement */
	32: optional bool requiresSurrender;
	
	/** Set to true if this is a shared license */
	33: bool sharedLicense = 0;
	
	/** Total number of seats for a shared license. Will only be set for a shared license. */
	34: i32 totalSeats;	
	
	/** Number of seats that have been allocated for a shared license. Will only be set for a shared license. */
	35: i32 allocatedSeats;
	
	/** Start of the subscription renewal period within which a subscription auth's stop date could be updated. */
	36: optional string subscriptionRefreshDate;
	
	/** Subscription period specified as # units */
	37: optional string subscriptionPeriod;
	
	/** Identifies this DrightInfo. Intended to be used with the EdenRemote API. */
	38: optional string drightGuid;
	
	/** GUID of the terms for this Dright. Only populated for EdenRemote API. */
	39: optional string termsGuid;
	
	/** This will be set to true if the auth has been archived and false otherwise. */
	40: bool archived;
    
	/** For EdenRemote clients, return the product GUID in addition to the authId. */
	41:	optional string productGuid;
	
	/** Set true if this is the top level parent auth for a Collection */
	42: bool collectionParent = 0;
	
	/** First date the auth was activated. Not present if never activated. */
	43: optional string firstActivateDate;
	
	/** 
	 The Authorization description - this will be the contents of the optional "Notes" as entered on the PaceCentral
	 Deposit page, or the contents of the optional description field of the AccountingInfo provided for an EdenRemote 
	 deposit. Since both sources for this information are optional, this string may not be present.
	 */
	44: optional string description;
	
	/** If present, this Dright has an override string to be used in place of the License Type name. Not available to all Publishers.*/
	45: optional string licenseTypeOverrideSelector;
	
	/** If present, then this Dright has release limits. Not available to all Publishers. */
	46: optional DrightReleaseLimits releaseLimits;

	/**
	 This optional data member can be returned by API calls that return a DrightInfoList, which means all of the EdenRemote calls that query
	 for User licenses. If a map is returned, it will be in the FIRST DrightInfo in the list, and will contain the override string GUID mappings
	 for ALL of the DrightInfos in the list. Each map entry uses a licenseTypeOverrideSelector (see member 45 above) as the key to select
	 a map of locale string keys to localized text strings. We currently suport only EN-US strings, so each localized text map will have a single
	 entry.
	 */
	47: optional LocalizedStringMap stringMap,			/** Lookup table for all overridden strings in all returned DrightInfos. */
}

/**
 Define a list of DrightInfo structures.
 */
typedef list<DrightInfo> DrightInfoList


/**
 Structure that tells the client side what information the publisher wants to collect in the case of an anonymous activation.
 This is used to configure the inline activation experience and, eventually, MyLicenses for a pukka code-based
 anonymous activation. Note that we ALWAYS collect the email address because PACE wants it. The publishers can have it too,
 but we don't need to specify it here.
 */
struct PublisherDataCollectionSpec
{
	1: bool collectName		= 0,		/** Please collect the name data */
	2: bool requireName		= 0,		/** Name data is required */
	3: bool collectAddress	= 0,		/** Please collect the address data */
	4: bool requireAddress	= 0,		/** Address data is required */
	5: bool collectPhone	= 0,		/** Please collect the phone data */
	6: bool requirePhone	= 0,		/** Phone data is required */
}


/**
 Structure used for all preflight operations, includes a structure specific to preflightRedeem.
 The preflight operations include activate, deactivate, move, transferToAnotherAccount and redeem.
 */
struct PreflightResult
{
	1:	i32 remainingActivations = 0,
	2:	optional list<DrightInfo> surrenderList,						/** What must be surrendered */
	3:	optional list<DrightInfo> approvalList,							/** Things requiring publisher approval */
	4:	optional list<DrightInfo> notPermittedList,						/** Things for which action is not permitted */
	5:	optional list<ActivationLocation> allowedDestinations,			/** for preflightActivate and preflightMove */
	6:	optional list<DisallowedDestination> disallowedDestinations,	/** for preflightActivate and preflightMove */
	7:	optional bool drightsDelivered = 0,								/** False - Will be delivered; True - Already available */
	8:	optional list<DrightInfo> grantedRights,						/** List of rights that will be delivered */
	9:	optional string objectGuid,										/** For list operations this identifies which object the result is for */
	10:	optional string drightGuid,										/** For certain operations we need to return the guid of a dright from an activation */
	11: bool accountRequired,											/** Indicates if an account is required when redeeming a pukka code */
	12: optional PublisherDataCollectionSpec publisherDataSpec,			/** Indicates data the activation experience should collect. Only included in accountRequired == false*/
	13: optional i32 publisherNoteMaximumLength,						/** Max length of the string for the note to publishers. Used for transfers requiring publisher approval. */
}


/**
 Enum for status of deliveries
 */
enum DeliveryStatus
{
	Pending = 1,
	Started,
	Complete,
	Disabled,
	Cancelled
}

/**
 Structure to convey before and after state of migrated Drights
 */
struct DrightMigration
{
	1:	DrightInfo	before,		/** Before DrightInfo */
	2:	DrightInfo	after,		/** After modification */
}

/**
 Structure to pass the details of a delivery to the end-user, once all choices have been made
 */
struct PreflightDeliveryResult
{
	1:	optional list<DrightInfo> surrenders,		/** List of Drights that will be surrendered */
	2:	optional list<DrightInfo> adds,				/** List of Drights that will be granted */
	3:	optional list<DrightMigration> migrations,	/** List of before/after Drights that will be modified */
	4:	optional list<DrightInfo> adjusted,			/** List of Drights that will be adjusted */
}

/**
 Structure used to detail a Delivery, either pending of started
 */
struct Delivery
{
	1:	string deliveryGuid,					/** Guid of this delivery */
	2:	string title,							/** Title assigned by publisher */
	3:	DeliveryStatus status = DeliveryStatus.Pending,		/** Status of this delivery */
	4:	optional PreflightDeliveryResult preflightDelivery,	/** Preflight Delivery Result so clients like MyLicenses can show details about the delivery without calling some other method. */
	5:	string participant,						/** Publisher name */
	6:	string depositDate,						/** Date this delivery was deposited to user's account */
}

/**
 Structure returned from getLibary operation
 */
struct LibraryInfo
{
	1:	list<DrightInfo> drights,
	2:	optional list<Delivery> deliveries,
	3:	string lastAuthPopulationDate,					/** Returns the last time that the auth (formerly dright) population date changed via deposit or transfer. */
	4:	optional list<DrightInfo> drightsLost,			/** Returns list of Drights that have been transferred out of the account since a specified date. Added for getLibraryWithFilters(). */
	5:	i32 archivedLicensesCount,						/** Total number of archived licenses in the account not including any unlocked or locked group parents. This count will be used by iLok License Manager. */
	6:	optional list<DrightInfo> sharedDrights,		/** Separate list of shared auths. Publishers and the Experience don't deal with shared auths for activation/deactivation. */
	7:  optional LocalizedStringMap stringMap,			/** Lookup table for all overridden strings in the drights list. Only present if at least one DrightInfo has a licenseTypeOverrideSelector member present. */
}

//-------
/**
 Thrift data ID of persistent form of LibraryInfo. The value is actually 'lits' in little endian.
 WARNING! Since this value is persisted into files, it can really never change.
 */
const i32 kLibraryInfoThriftDataId			= 0x7374696c

//-------

/**
Defines the type of the handle value returned for Activation Service operations.
*/
typedef i32 OperationHandle_T

/**
Defines the type of the handle value returned by getVisibleActivationsCollection().
*/
typedef i32 ActivationCollectionHandle_T

/**
Defines the type of the handle value returned by getAccountAuthorizationsCollection()
*/
typedef i32 AuthorizationCollectionHandle_T

/**
The possible sub-collection specifiers for authorizationsBegin(), authorizationsNext(), and authorizationsCurrent().
*/	
enum AuthorizationCollectionType
{
	authorizationHasActivationsAvailable,		/** Auths that can be activated */
	authorizationNoActivationsAvailable,		/** Auths that cannot be activated */
}
	
/**
 The possible sub-collection specifiers for activationsBegin(), activationsNext(), and activationsCurrent().
*/	
enum ActivationCollectionType
{
	accountMachineActivations,		/** Activations on the local machine that belong to the authenticated account */
	accountIlokActivations,			/** Activations on iLoks that belong to the authenticated account */
	otherMachineActivations,		/** Activations on the local machine that are anonymous or belong to another account */
	otherIlokActivations,			/** Activations on iLoks that do not belong to the authenticated account */
}

/**
Returned by the traversal functions for both Authorizations and Activations. This contains the data that is displayed
by the PACE activation and deactivation experiences. The authType, suthSubtype, authState, and locationNAme strings 
will have been translated into their standard format as displayed by the experiences and iLok License Manager.

The isExpired, isAuthorized, isQueued, and deactivationOperationId members are populated by the Activation traversal calls.
The activationOperationId member is populated by the Authorization traversal calls.
*/
struct StandardAuthorizationDisplayData
{
	1:	string	authName,							/** The standard auth name string */
	2:	string	authType,							/** The standard authType string */
	3:	string	authSubtype,						/** The standard authSubtype string */
	4:	string	authState,							/** The standard authState string */
	5:	string	locationName,						/** The standard location name string */
	
	11:	optional bool	isExpired,					/** IF present, tells whether the Authorization is expired. */
	12:	optional bool	isAuthorized,				/** If present, indicates whether the Activation is authorized. */
	13: optional bool	isQueued,					/** If present, then the activation is on an iLok1 and is queued if true. */
	
	21: optional string	activationOperationId,		/** If present, the ID value that can be used to activate the Authorization */
	22:	optional string	deactivationOperationId,	/** If present, the ID value that can be used to deactivate the Activation. */
}

//-----------------------
// This is the API used to authenticate a session.
struct AuthenticateSessionRequest
{
	1:	string accountId,							/** The account user name */
	2:	string authenticationToken,					/** This token enables the publisher to perform activation or deactivation operations on
														behalf of the user. The normal case would be that this is the OAuth access token obtained
														from PACE's OAuth service provider or from an EdenRemote method call. For testing purposes,
														this token could also be from the publisher's activation test account. The test account tokens 
														are defined by PACE and available on request from support. */
}

//-----------------------
// This is the API used to refresh subscription auth activations.

/** Status values about the auth refresh. Used for the preflight and the actual refresh call.
 For the preflight call, the intent is to know what the server would do if you made the refresh call.
 If the refresh call would extend the end date of the activation, then we expect to get 
 SubscriptionAuthRefreshStatus_NewEndDate back from the preflgight call.
 If the refresh call would not change the end date of the activation because we are not within
 the time window where automatic stop date extension is allowed, the we expect to get
 SubscriptionAuthRefreshStatus_Unchanged back from the preflight call.
 If the refresh call would not extend the end date of the activation because we have been told
 that the subscription is currently terminated, we expect the preflight call to
 return SubscriptionAuthRefreshStatus_Terminated.
 
 Remember that the preflight call can also be used to get a list of auths that the server believes
 can be refreshed at the current time. This is equivalent to getting the status of
 SubscriptionAuthRefreshStatus_NewEndDate for each of the auths in the list.
 
 The statuses are a little more straightforward when returned from the refresh call. Their
 meanings are in the comments below.
 */
enum eSubscriptionAuthRefreshStatus
{
	SubscriptionAuthRefreshStatus_NewEndDate = 0,	/** Refresh gave or will give the activation a new end date.
														This can be returned by preflightRefreshSubscriptionAuth() or refreshSubscriptionAuth(). */
	SubscriptionAuthRefreshStatus_Unchanged,		/** Refresh could not give the activation a new end date. This could be because the refresh call was made before the refresh window.
														This can be returned by preflightRefreshSubscriptionAuth() or refreshSubscriptionAuth(). */
	SubscriptionAuthRefreshStatus_Expired,			/** Refresh determined that the subscription is currently expired and cannot be refreshed. Can be returned by
														preflightRefreshSubscriptionAuth() or refreshSubscriptionAuth(). End date not changed. */
	SubscriptionAuthRefreshStatus_Failure,			/** Refresh failed. Activation end date is unchanged. */
    SubscriptionAuthRefreshStatus_WaitingForManualRefresh,  /** The auth requires manual refresh, we are within the refresh window, and the auth has an active status that is not suspended or terminated,
                                                                so we are waiting for the publisher to refresh it. This should never be returned for an auth that refreshes automatically. */
}

/** This represents the relationship between the time at which the preflightRefreshSubscriptionAuth or refreshSubscriptionAuth
 call was made and the various time points that are important to subscriptions.
 
 Please refer to the documentation for the TimeLimitRecord. We will refer to the Subscription settings diagram in the
 description that follows and the documentation of the enum values.
 
 This enum shows the relationship between the time the call was made and points A, B, C, and D in the TimeLimitRecord diagram.
 */
enum eSubscriptionRefreshTimeRelationship
{
    SubscriptionRefreshTimeRelationship_OutsideRefreshWindow,	/** Either before or after the auth’s total refresh + grace period window. Before A or after D in the TimeLimitRecord diagram.
                                                                    If before A, eSubscriptionAuthRefreshStatus value will be SubscriptionAuthRefreshStatus_Unchanged. If after D,
                                                                    eSubscriptionAuthRefreshStatus value will be SubscriptionAuthRefreshStatus_Expired. */
    SubscriptionRefreshTimeRelationship_InRefresh,              /** Currently in the refresh window. Between points B and C in the TimeLimitRecord diagram */
    SubscriptionRefreshTimeRelationship_InGrace,                /** Currently in the grace period. Between points C and D in the TimeLimitRecordDiagram. */
} 

/** This represents the disposition of an activation after processing a refresh request.
 It tells whether the activation remains in place on the location or was removed from the location. */
enum eSubscriptionAuthActivationStatus
{
	eSubscriptionAuthActivationStatus_InPlace = 0,	/** The activation is still in place on the original location. */
	eSubscriptionAuthActivationStatus_Removed,		/** The activation was removed from the location. */
}

/** This just packs the two status values together in a single struct. */
struct RefreshSubscriptionAuthStatus
{
	1:	eSubscriptionAuthRefreshStatus		refreshStatus,		/** Status for the auth specified in the request. */
	2:	eSubscriptionAuthActivationStatus	activationStatus,	/** Status for the activation. Still on the location or not? */
	3:	string								refreshAfterDate,	/** Start of the subscription renewal period. */
	4:	string								subscriptionPeriod,	/** Subscription period specified as # units */
	5:	string								expirationDate,		/** Expiration date of the subscription auth. */
}

/** This defines what the server should do with an auth that cannot be refreshed. */
enum eFailedSubscriptionActivationRefreshAction
{
	eFailedSubscriptionActivationRefreshRemove = 0,			/** Remove (deactivate) the activation from the location. */
	eFailedSubscriptionActivationRefreshLeaveInPlace,		/** Leave the activation in place. */
}

/** This is supposed to represent an activation for a subscription auth that the server believes is
 a candidate for refresh. I am assuming for now that the identifier is a pkid value for an activation,
 but it is up to Joel to decide what is necessary here. The strings are used by the client side code to
 present info to the user.
 */
struct OtherSubscriptionAuthIdentifier
{
	1:	i64				identifier,					/** Server-specific identifier for the activation to refresh. */
	
	11:	string			name,						/** The auth name */
	12:	string			publisherName,				/** The publisher's name */
	13:	string			locationName,				/** The name of the location where the activation is located. The serial number if an iLok. */
	14:	eLocationType	locationType,				/** The location type. */
	15:	optional string iLokStorageLocation,		/** iLok storage location if this is an iLok activation */
}

/** These are the calling arguments for a preflightRefreshSubscriptionAuth() call to the server.
 The data identifies the particular activation of interest, and is copied from an AuthChain.
 The boolean is used to control whether information about other auths is returned. It can be
 set false if the client code doesn't care about other auths.
 */
struct PreflightRefreshSubscriptionAuthRequest
{	// The structure should contain either an AuthChain OR an AuthSituation, depending on how you were notified that the subscription auth needs to be refreshed. */
	1:	optional AuthChain		authToRefreshByChain,					/** The AuthChain that identifies the auth whose activation is to be refreshed. */
	2:	optional AuthSituation	authToRefreshBySituation,				/** The AuthSituation that identifies the auth whose activation is to be refreshed. */
	
	// Control information
	11: bool					getInfoForAllVisibleSubscriptions = 1,	/** If true, then the call returns a list of auth activations
																			that are within their refresh period. */
}

/** This is the data returned from the preflightRefreshSubscriptionAuth call. The status value for the
 particular auth of interest and a possibly empty list of other auths that can be refreshed at this time.
 The otherAuths list will be populated if the getInfoForAllVisibleSubscriptions data member was set true 
 in the request, regardless of the status returned for the auth of interest.
 
 The suppressWarnings flag is set by the server based on the time of the preflightRefresh
 call relative to the refresh window and grace periods and the subscription terms setting that suppresses
 warnings during the refresh window and grace period. The setting of this flag rep[resents the wishes of
 the publisher in regard to the subscription terms being used. The activation experience pays attention to
 this flag. Your code may need to do the same.
 
 The isManualRefresh, nonzeroRefresh, nonmzeroGrace, and refreshRelationship data members are designed to 
 return all the detail you could possibly require to figure out what message, if any, you might want to
 display to the user about the subscription. These are mainly useful if you get back a status value of
 SubscriptionAuthRefreshStatus_Unchanged and might need to tell the user something.
  */
struct PreflightRefreshSubscriptionAuthReply
{
	1:	eSubscriptionAuthRefreshStatus			status,                 /** Status for the activation specified in the request. */
	2:	bool									suppressWarnings = 0,	/** If true, then the server wants the experience to not show any subscription warnings. */
    3:  bool                                    isManualRefresh = 0,    /** If true, then the subscription refreshes manually. */
    4:	bool                                    nonzeroRefresh = 0,     /** If true, the subscription terms have a nonzero refresh window. */
    5:	bool                                    nonzeroGrace = 0,		/** If true, the subscription terms have a nonzero grace period. */
    6:	eSubscriptionRefreshTimeRelationship    refreshRelationship,	/** How time of preflightRefresh call falls relative to refresh and grace periods. */
	
	7:	string									refreshUrlOverride,		/** If there is a URL override available for refreshing the subscription, it is returned here. Empty string if none. */
	8:  string									drightGuid,				/** The UUID that identifies the Authorization of interest. Used to compose the subscription refresh URL if
																			refreshUrlOverride is non-empty. */
	
	11: list<OtherSubscriptionAuthIdentifier>	otherAuths,	/** List of auths available for refresh. Will be empty if getInfoForAllVisibleSubscriptions is false in the preflight request. */
}

/** These are the calling arguments for the refreshSubscriptionAuth() server call.  The data identifies the particular
 activation of interest, and is copied from an AuthChain. The optional list of other auths to refresh is either
 the same list returned by the preflight call, or a subset of that list. The server will attempt to refresh
 each specified auth.
 */
struct RefreshSubscriptionAuthRequest
{	// The structure should contain either an AuthChain OR an AuthSituation, depending on how you were notified that the subscription auth needs to be refreshed. */
	1:	optional AuthChain									authToRefreshByChain,		/** The AuthChain that identifies the auth whose activation is to be refreshed. */
	2:	optional AuthSituation								authToRefreshBySituation,	/** The AuthSituation that identifies the auth whose activation is to be refreshed. */
														
	11: optional list<OtherSubscriptionAuthIdentifier>		otherAuths,					/** List of other auths to refresh. Optional. May be 
																							empty if present. In general, this is the (edited) 
																							list returned by the preflight call. */
	21: optional eFailedSubscriptionActivationRefreshAction	failedRefreshAction,		/** If present, specifies the behavior for activations that cannot be refreshed. */ 
}

/** This is the data returned from the refreshSubscriptionAuth() call. The first status item is for
 the particular activation of interest. The list contains status for each of the other auths specified
 in the request, so it can be empty.
 */
struct RefreshSubscriptionAuthReply
{
	1:	RefreshSubscriptionAuthStatus		primaryAuthStatus,	/** Status for the specific auth specified in the request. */
	
	11: list<RefreshSubscriptionAuthStatus>	otherAuthsStatus,	/** Status for the "other auths" in the request, in the same 
																 order as the request list. Empty if no other auths specified. */
}

//-----------------------
// Thiese definitions are to support the serviceLocationsStart() Eden Activation API call.

/**
 The different operations that serviceLocations normally performs. Specify one or more of these in specificServiceOpFlags to limit the operations to the ones specified.
 
 The serviceLocations call always executes iLoks if required and does required auto-syncs on modern iLoks. Normally it will also do all the operations defined
 by the enum, but you can specify a subset of available operations to limit the scope of the call.
 */
enum kServiceLocationOperations
{
	kUpgradeCollections		= 0x00000001,	/** Upgrade Collections on specified modern locations. */
	kRefreshSubscriptions	= 0x00000002,	/** Attempt to refresh subscriptions on specified modern locations. */
}

/** The data type we will define to hold OR'ed kServiceLocationOperations values for the serviceLocations call. */
typedef i32 eServiceLocationOperations

/**
 What serviceLocations did on any one location. Multiple bit flags could be set, indicating, for instance,m that we synced an iLok and upgraded one or more Collections on it.
 */
enum kServiceLocationResult
{
	kLocUnchanged				= 0x00000000,	/** Nothing was done to the location. */
	kLocExecuted				= 0x00000001,	/** An iLok was executed because it had been reported lost or stolen. */
	kLocSynced					= 0x00000002,	/** An iLok was synchronized. */
	kLocCollectionUpgrade		= 0x00000004,	/** One or more Collections were upgraded on the location. */
	kLocSubscriptionRefresh		= 0x00000008,	/** One or more subscriptions were refreshed on the location. */
	
	kLocNotConnected			= 0x20000000,	/** The specified location is not visible on the local machine. */
	kLocNotFound				= 0x40000000,	/** The specified location is not known to the activation server */
}

/** The data type we will define to hold OR'ed kServiceLocationResult values in the ServiceLocationsResult. */
typedef i32 eServiceLocationResult

/**
 This structure is used to call serviceLocations.
 
 If all you want to do is service all visible iLoks and the machine (what we think is the most common use case), use an uninitialized ServiceLocationsRequest struct.
 
 To service all visible iLoks and NOT the machine, set serviceMachine false in an otherwise uninitialized ServiceLocationsRequest struct.
 
 To service ONLY the machine, do this:
  - ServiceLocationsRequest request;
    std::vector<IlokSerialNumber_T> emptyIlokVector;
    PACE_SET_THRIFT_DATA_MEMBER(request, specificIloks, emptyIlokVector);
 The example uses our PACE_SET_THRIFT_DATA_MEMBER macro because it also sets the corresponding __isset, which must be set when an optional mamber is present.
 
 To service a specific set of iLoks that you know about, set their serial numbers into a std::vector<IlokSerialNumber_T> and set that as specificIloks. Remember to set the __isset!
 
 To limit the operations that are attempted, provide specificServiceOpFlags (and it's __isset, of course). It is bit encoded to specify the operations you want to perform. You
 cannot disable iLok execution nor auto-sync.
 */
struct ServiceLocationsRequest
{
	1: bool serviceMachine = 1,										/** If true (the default), then service the machine location as well as any iLoks. */
	2: optional eServiceLocationOperations specificServiceOpFlags,	/** Used to request a specific set of operations. Not present by default, so all operations are performed. */
	3: optional list<IlokSerialNumber_T> specificIloks,				/** If not present (the default), service all visible iLoks.
																	    If present and empty, ignore all iLoks.
																	    If present and not empty, service only the specified iLoks. */
}

/**
 This tells us what happened during serviceLocations. We need a result for every iLok that was considered because we may not know the list
 if we did not provide a specificIloks vector in the request.
 
 Note that this result will be empty (all __isset values false) if the request was to service all visible iLoks, but not the machine, and there are no visible iLoks.
 */
struct ServiceLocationsResult
{
	1: optional map<IlokSerialNumber_T, eServiceLocationResult> ilokResults,	/** An eServiceLocationResult per-iLok. Not present if no iLoks were processed. */
	2: optional eServiceLocationResult machineResult,							/** An eServiceLocationResult for the machine location if it was processed. Not present otherwise. */
}


//-----------------------
/**
 This structure is used to create a new account, many of the parameters have default empty values to allow for "simple" registration.
 It will be passed unchanged to the server.
 */
struct UserAccount
{
	/** The desired account ID. This is required for account creation, and is returned in EdenRemote queries. */
	1:	string accountId,
	
	/** Password is passed in cleartext. This is required for account creation, and is never returned in EdenRemote queries. */
	2:	string password,
	
	/** Email for this account. This is required for account creation, and is returned in EdenRemote queries. */
	3:	string primaryEmail,
	4:	optional string firstName,
	5:	optional string firstNamePhonetic,
	6:	optional string firstNameRomagi,
	7:	optional string middleName,
	8:	optional string middleNamePhonetic,
	9:	optional string middleNameRomagi,
	10:	optional string lastName,
	11:	optional string lastNamePhonetic,
	12:	optional string lastNameRomagi,
	13:	optional string companyName,
	
	/** Index of canned security questions */
	14:	optional string securityQuestion,
	15:	optional string securityAnswer,
	
	16:	optional string locale,
	17:	optional string timeZone,
	18:	optional bool allowUpdateNotification,
	19:	optional bool allowThirdPartyNotification,
	20:	optional i32 birthdayMonth,
	21:	optional i32 birthdayDay,
	
	/** If true, this is a test account which can be flushed via the EdenRemote flushTestAccount service call. */
	22: optional bool isTestAccount,
	
	/** If set, then this is the PACE customer who created the account on behalf of the user. If not set, then
		The user created this account via the normal iLok.com mechanism. */
	23:	optional Identity accountCreator,
	
	/** If true, this read-only flag indicates that the account was created by a PACE customer on behalf of a user. If a user has claimed their
		account after it was created on their behalf, this flag will be false. */
	24:	bool provisional = 0,
	
	/** If true, this read-only flag indicates that the account has been disabled by PACE for some reason. You may not deposit to disabled accounts. */
	25:	bool disabled = 0,

	/** If true, this read-only flag indicates that the account has been disabled due to fraudulent activity or violations of our terms. */
	26:	bool fraudLocked = 0,
	
    /** DateTime that the account was created */
    27: optional string creationDate,
	
    /** DateTime of last user login */
    28: optional string lastLoginDate,
	
	/** If true, this read-only flag indicates that PACE has confirmed the user's email address, or that a PACE publisher created the account
		(presumably after verifying the email address themselves). If a publisher created the account, then the 'provisional' flag may also be set
		if the user has not claimed their account. */
	29:	bool confirmedEmail = 0,
	
}

/** Define a list of user account structures. */
typedef list<UserAccount> UserAccountList

